// ** WARNING **
// This file is autogenerated by Javelin Object Compiler (joc).
// Do not edit it directly.
//
// ignore_for_file: annotate_overrides
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: directives_ordering
// ignore_for_file: prefer_const_constructors_in_immutables
// ignore_for_file: sort_constructors_first
// ignore_for_file: unused_import
import 'package:javelin_object/jo_internal.dart';

import '../void.jo.dart';

@immutable
class ColumnReferenceAstNode {
  const ColumnReferenceAstNode({
    required this.columnName,
    required this.valueType,
  });

  final String columnName;
  final ValueType valueType;

  Map<String, Object?> toMap() {
    final $columnName = columnName;
    final $valueType = valueType;

    return {
      'columnName': $columnName,
      'valueType': $valueType.toMap(),
    };
  }

  @override
  int get hashCode {
    var result = 0;
    result = joCombineHashCode(result, columnName.hashCode);
    result = joCombineHashCode(result, valueType.hashCode);
    return joFinalizeHashCode(result);
  }

  @override
  bool operator==(Object other) =>
    other is ColumnReferenceAstNode
    && columnName == other.columnName
    && valueType == other.valueType;

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

@immutable
class ComparisonAstNode {
  const ComparisonAstNode({
    required this.first,
    required this.second,
  });

  final AstNode first;
  final AstNode second;

  Map<String, Object?> toMap() {
    final $first = first;
    final $second = second;

    return {
      'first': $first.toMap(),
      'second': $second.toMap(),
    };
  }

  @override
  int get hashCode {
    var result = 0;
    result = joCombineHashCode(result, first.hashCode);
    result = joCombineHashCode(result, second.hashCode);
    return joFinalizeHashCode(result);
  }

  @override
  bool operator==(Object other) =>
    other is ComparisonAstNode
    && first == other.first
    && second == other.second;

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

@immutable
class MethodCallAstNode {
  const MethodCallAstNode({
    required this.receiver,
    required this.methodName,
    required this.fixedParameters,
    required this.optionalParameters,
  });

  final AstNode receiver;
  final String methodName;
  final List<MethodCallParameter> fixedParameters;
  final Map<String, MethodCallParameter> optionalParameters;

  Map<String, Object?> toMap() {
    final $receiver = receiver;
    final $methodName = methodName;
    final $fixedParameters = fixedParameters;
    final $optionalParameters = optionalParameters;

    return {
      'receiver': $receiver.toMap(),
      'methodName': $methodName,
      'fixedParameters': $fixedParameters.map((e) => e.toMap()).toList(),
      'optionalParameters': $optionalParameters.map((k, v) => MapEntry(k, v.toMap())),
    };
  }

  @override
  int get hashCode {
    var result = 0;
    result = joCombineHashCode(result, receiver.hashCode);
    result = joCombineHashCode(result, methodName.hashCode);
    result = joCombineHashCode(result, const ListEquality().hash(fixedParameters));
    result = joCombineHashCode(result, const MapEquality().hash(optionalParameters));
    return joFinalizeHashCode(result);
  }

  @override
  bool operator==(Object other) =>
    other is MethodCallAstNode
    && receiver == other.receiver
    && methodName == other.methodName
    && const ListEquality().equals(fixedParameters, other.fixedParameters)
    && const MapEquality().equals(optionalParameters, other.optionalParameters);

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

@immutable
class MethodCallParameter {
  const MethodCallParameter({
    required this.name,
    required this.valueType,
  });

  final String name;
  final ValueType valueType;

  Map<String, Object?> toMap() {
    final $name = name;
    final $valueType = valueType;

    return {
      'name': $name,
      'valueType': $valueType.toMap(),
    };
  }

  @override
  int get hashCode {
    var result = 0;
    result = joCombineHashCode(result, name.hashCode);
    result = joCombineHashCode(result, valueType.hashCode);
    return joFinalizeHashCode(result);
  }

  @override
  bool operator==(Object other) =>
    other is MethodCallParameter
    && name == other.name
    && valueType == other.valueType;

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

@immutable
class ParameterAstNode {
  const ParameterAstNode({
    required this.name,
    required this.valueType,
  });

  final String name;
  final ValueType valueType;

  Map<String, Object?> toMap() {
    final $name = name;
    final $valueType = valueType;

    return {
      'name': $name,
      'valueType': $valueType.toMap(),
    };
  }

  @override
  int get hashCode {
    var result = 0;
    result = joCombineHashCode(result, name.hashCode);
    result = joCombineHashCode(result, valueType.hashCode);
    return joFinalizeHashCode(result);
  }

  @override
  bool operator==(Object other) =>
    other is ParameterAstNode
    && name == other.name
    && valueType == other.valueType;

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

@immutable
class ClassType {
  const ClassType({
    required this.className,
  });

  final String className;

  Map<String, Object?> toMap() {
    final $className = className;

    return {
      'className': $className,
    };
  }

  @override
  int get hashCode {
    var result = 0;
    result = joCombineHashCode(result, className.hashCode);
    return joFinalizeHashCode(result);
  }

  @override
  bool operator==(Object other) =>
    other is ClassType
    && className == other.className;

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

@immutable
class EnumType {
  const EnumType({
    required this.enumName,
  });

  final String enumName;

  Map<String, Object?> toMap() {
    final $enumName = enumName;

    return {
      'enumName': $enumName,
    };
  }

  @override
  int get hashCode {
    var result = 0;
    result = joCombineHashCode(result, enumName.hashCode);
    return joFinalizeHashCode(result);
  }

  @override
  bool operator==(Object other) =>
    other is EnumType
    && enumName == other.enumName;

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

@immutable
class MethodType {
  const MethodType({
    required this.returnType,
    required this.fixedParameters,
    required this.optionalParameters,
  });

  final ValueType returnType;
  final List<MethodCallParameter> fixedParameters;
  final Map<String, MethodCallParameter> optionalParameters;

  Map<String, Object?> toMap() {
    final $returnType = returnType;
    final $fixedParameters = fixedParameters;
    final $optionalParameters = optionalParameters;

    return {
      'returnType': $returnType.toMap(),
      'fixedParameters': $fixedParameters.map((e) => e.toMap()).toList(),
      'optionalParameters': $optionalParameters.map((k, v) => MapEntry(k, v.toMap())),
    };
  }

  @override
  int get hashCode {
    var result = 0;
    result = joCombineHashCode(result, returnType.hashCode);
    result = joCombineHashCode(result, const ListEquality().hash(fixedParameters));
    result = joCombineHashCode(result, const MapEquality().hash(optionalParameters));
    return joFinalizeHashCode(result);
  }

  @override
  bool operator==(Object other) =>
    other is MethodType
    && returnType == other.returnType
    && const ListEquality().equals(fixedParameters, other.fixedParameters)
    && const MapEquality().equals(optionalParameters, other.optionalParameters);

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

@immutable
class UnionType {
  const UnionType({
    required this.unionName,
  });

  final String unionName;

  Map<String, Object?> toMap() {
    final $unionName = unionName;

    return {
      'unionName': $unionName,
    };
  }

  @override
  int get hashCode {
    var result = 0;
    result = joCombineHashCode(result, unionName.hashCode);
    return joFinalizeHashCode(result);
  }

  @override
  bool operator==(Object other) =>
    other is UnionType
    && unionName == other.unionName;

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

@immutable
class ClassValue {
  const ClassValue({
    required this.classType,
    required this.parameters,
  });

  final ClassType classType;
  final Map<String, Value> parameters;

  Map<String, Object?> toMap() {
    final $classType = classType;
    final $parameters = parameters;

    return {
      'classType': $classType.toMap(),
      'parameters': $parameters.map((k, v) => MapEntry(k, v.toMap())),
    };
  }

  @override
  int get hashCode {
    var result = 0;
    result = joCombineHashCode(result, classType.hashCode);
    result = joCombineHashCode(result, const MapEquality().hash(parameters));
    return joFinalizeHashCode(result);
  }

  @override
  bool operator==(Object other) =>
    other is ClassValue
    && classType == other.classType
    && const MapEquality().equals(parameters, other.parameters);

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

@immutable
class EnumValue {
  const EnumValue({
    required this.enumType,
    required this.enumValueName,
  });

  final EnumType enumType;
  final String enumValueName;

  Map<String, Object?> toMap() {
    final $enumType = enumType;
    final $enumValueName = enumValueName;

    return {
      'enumType': $enumType.toMap(),
      'enumValueName': $enumValueName,
    };
  }

  @override
  int get hashCode {
    var result = 0;
    result = joCombineHashCode(result, enumType.hashCode);
    result = joCombineHashCode(result, enumValueName.hashCode);
    return joFinalizeHashCode(result);
  }

  @override
  bool operator==(Object other) =>
    other is EnumValue
    && enumType == other.enumType
    && enumValueName == other.enumValueName;

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

@immutable
class MethodValue {
  const MethodValue({
    required this.methodType,
  });

  final MethodType methodType;

  Map<String, Object?> toMap() {
    final $methodType = methodType;

    return {
      'methodType': $methodType.toMap(),
    };
  }

  @override
  int get hashCode {
    var result = 0;
    result = joCombineHashCode(result, methodType.hashCode);
    return joFinalizeHashCode(result);
  }

  @override
  bool operator==(Object other) =>
    other is MethodValue
    && methodType == other.methodType;

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

@immutable
class UnionValue {
  const UnionValue({
    required this.unionType,
    required this.activeElementName,
    this.value,
  });

  final UnionType unionType;
  final String activeElementName;
  final Value? value;

  Map<String, Object?> toMap() {
    final $unionType = unionType;
    final $activeElementName = activeElementName;
    final $value = value;

    return {
      'unionType': $unionType.toMap(),
      'activeElementName': $activeElementName,
      if ($value != null)
        'value': $value.toMap(),
    };
  }

  @override
  int get hashCode {
    var result = 0;
    result = joCombineHashCode(result, unionType.hashCode);
    result = joCombineHashCode(result, activeElementName.hashCode);
    result = joCombineHashCode(result, value.hashCode);
    return joFinalizeHashCode(result);
  }

  @override
  bool operator==(Object other) =>
    other is UnionValue
    && unionType == other.unionType
    && activeElementName == other.activeElementName
    && value == other.value;

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

enum AstNodeType {
  negate,
  logicalAnd,
  logicalOr,
  constant,
  columnReference,
  methodCall,
  parameter,
  equals,
  notEquals,
  lessThan,
  lessThanOrEquals,
}

class AstNode {
  AstNode.negate(AstNode negate)
    : type = AstNodeType.negate,
      _value = negate;

  AstNode.logicalAnd(List<AstNode> logicalAnd)
    : type = AstNodeType.logicalAnd,
      _value = logicalAnd;

  AstNode.logicalOr(List<AstNode> logicalOr)
    : type = AstNodeType.logicalOr,
      _value = logicalOr;

  AstNode.constant(Value constant)
    : type = AstNodeType.constant,
      _value = constant;

  AstNode.columnReference(ColumnReferenceAstNode columnReference)
    : type = AstNodeType.columnReference,
      _value = columnReference;

  AstNode.methodCall(MethodCallAstNode methodCall)
    : type = AstNodeType.methodCall,
      _value = methodCall;

  AstNode.parameter(ParameterAstNode parameter)
    : type = AstNodeType.parameter,
      _value = parameter;

  AstNode.equals(ComparisonAstNode equals)
    : type = AstNodeType.equals,
      _value = equals;

  AstNode.notEquals(ComparisonAstNode notEquals)
    : type = AstNodeType.notEquals,
      _value = notEquals;

  AstNode.lessThan(ComparisonAstNode lessThan)
    : type = AstNodeType.lessThan,
      _value = lessThan;

  AstNode.lessThanOrEquals(ComparisonAstNode lessThanOrEquals)
    : type = AstNodeType.lessThanOrEquals,
      _value = lessThanOrEquals;

  AstNodeType type;
  Object _value;

  AstNode get negate => negateOrNull!;
  AstNode? get negateOrNull =>
    type == AstNodeType.negate
      ? _value as AstNode
      : null;
  set negate(AstNode value) {
    type = AstNodeType.negate;
    _value = value;
  }

  List<AstNode> get logicalAnd => logicalAndOrNull!;
  List<AstNode>? get logicalAndOrNull =>
    type == AstNodeType.logicalAnd
      ? _value as List<AstNode>
      : null;
  set logicalAnd(List<AstNode> value) {
    type = AstNodeType.logicalAnd;
    _value = value;
  }

  List<AstNode> get logicalOr => logicalOrOrNull!;
  List<AstNode>? get logicalOrOrNull =>
    type == AstNodeType.logicalOr
      ? _value as List<AstNode>
      : null;
  set logicalOr(List<AstNode> value) {
    type = AstNodeType.logicalOr;
    _value = value;
  }

  Value get constant => constantOrNull!;
  Value? get constantOrNull =>
    type == AstNodeType.constant
      ? _value as Value
      : null;
  set constant(Value value) {
    type = AstNodeType.constant;
    _value = value;
  }

  ColumnReferenceAstNode get columnReference => columnReferenceOrNull!;
  ColumnReferenceAstNode? get columnReferenceOrNull =>
    type == AstNodeType.columnReference
      ? _value as ColumnReferenceAstNode
      : null;
  set columnReference(ColumnReferenceAstNode value) {
    type = AstNodeType.columnReference;
    _value = value;
  }

  MethodCallAstNode get methodCall => methodCallOrNull!;
  MethodCallAstNode? get methodCallOrNull =>
    type == AstNodeType.methodCall
      ? _value as MethodCallAstNode
      : null;
  set methodCall(MethodCallAstNode value) {
    type = AstNodeType.methodCall;
    _value = value;
  }

  ParameterAstNode get parameter => parameterOrNull!;
  ParameterAstNode? get parameterOrNull =>
    type == AstNodeType.parameter
      ? _value as ParameterAstNode
      : null;
  set parameter(ParameterAstNode value) {
    type = AstNodeType.parameter;
    _value = value;
  }

  ComparisonAstNode get equals => equalsOrNull!;
  ComparisonAstNode? get equalsOrNull =>
    type == AstNodeType.equals
      ? _value as ComparisonAstNode
      : null;
  set equals(ComparisonAstNode value) {
    type = AstNodeType.equals;
    _value = value;
  }

  ComparisonAstNode get notEquals => notEqualsOrNull!;
  ComparisonAstNode? get notEqualsOrNull =>
    type == AstNodeType.notEquals
      ? _value as ComparisonAstNode
      : null;
  set notEquals(ComparisonAstNode value) {
    type = AstNodeType.notEquals;
    _value = value;
  }

  ComparisonAstNode get lessThan => lessThanOrNull!;
  ComparisonAstNode? get lessThanOrNull =>
    type == AstNodeType.lessThan
      ? _value as ComparisonAstNode
      : null;
  set lessThan(ComparisonAstNode value) {
    type = AstNodeType.lessThan;
    _value = value;
  }

  ComparisonAstNode get lessThanOrEquals => lessThanOrEqualsOrNull!;
  ComparisonAstNode? get lessThanOrEqualsOrNull =>
    type == AstNodeType.lessThanOrEquals
      ? _value as ComparisonAstNode
      : null;
  set lessThanOrEquals(ComparisonAstNode value) {
    type = AstNodeType.lessThanOrEquals;
    _value = value;
  }

  Map<String, Object?> toMap() {
    switch (type) {
      case AstNodeType.negate:
        final $negate = _value as AstNode;
        return { 'negate': $negate.toMap() };
      case AstNodeType.logicalAnd:
        final $logicalAnd = _value as List<AstNode>;
        return { 'logicalAnd': $logicalAnd.map((e) => e.toMap()).toList() };
      case AstNodeType.logicalOr:
        final $logicalOr = _value as List<AstNode>;
        return { 'logicalOr': $logicalOr.map((e) => e.toMap()).toList() };
      case AstNodeType.constant:
        final $constant = _value as Value;
        return { 'constant': $constant.toMap() };
      case AstNodeType.columnReference:
        final $columnReference = _value as ColumnReferenceAstNode;
        return { 'columnReference': $columnReference.toMap() };
      case AstNodeType.methodCall:
        final $methodCall = _value as MethodCallAstNode;
        return { 'methodCall': $methodCall.toMap() };
      case AstNodeType.parameter:
        final $parameter = _value as ParameterAstNode;
        return { 'parameter': $parameter.toMap() };
      case AstNodeType.equals:
        final $equals = _value as ComparisonAstNode;
        return { 'equals': $equals.toMap() };
      case AstNodeType.notEquals:
        final $notEquals = _value as ComparisonAstNode;
        return { 'notEquals': $notEquals.toMap() };
      case AstNodeType.lessThan:
        final $lessThan = _value as ComparisonAstNode;
        return { 'lessThan': $lessThan.toMap() };
      case AstNodeType.lessThanOrEquals:
        final $lessThanOrEquals = _value as ComparisonAstNode;
        return { 'lessThanOrEquals': $lessThanOrEquals.toMap() };
    }
  }
  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

enum ValueTypeKind {
  optionalType,
  boolType,
  intType,
  doubleType,
  stringType,
  classType,
  enumType,
  unionType,
  methodType,
}

class ValueType {
  ValueType.optionalType(ValueType optionalType)
    : kind = ValueTypeKind.optionalType,
      _value = optionalType;

  ValueType.boolType()
    : kind = ValueTypeKind.boolType,
      _value = const Void();

  ValueType.intType()
    : kind = ValueTypeKind.intType,
      _value = const Void();

  ValueType.doubleType()
    : kind = ValueTypeKind.doubleType,
      _value = const Void();

  ValueType.stringType()
    : kind = ValueTypeKind.stringType,
      _value = const Void();

  ValueType.classType(ClassType classType)
    : kind = ValueTypeKind.classType,
      _value = classType;

  ValueType.enumType(EnumType enumType)
    : kind = ValueTypeKind.enumType,
      _value = enumType;

  ValueType.unionType(UnionType unionType)
    : kind = ValueTypeKind.unionType,
      _value = unionType;

  ValueType.methodType(MethodType methodType)
    : kind = ValueTypeKind.methodType,
      _value = methodType;

  ValueTypeKind kind;
  Object _value;

  ValueType get optionalType => optionalTypeOrNull!;
  ValueType? get optionalTypeOrNull =>
    kind == ValueTypeKind.optionalType
      ? _value as ValueType
      : null;
  set optionalType(ValueType value) {
    kind = ValueTypeKind.optionalType;
    _value = value;
  }

  Void get boolType => boolTypeOrNull!;
  Void? get boolTypeOrNull =>
    kind == ValueTypeKind.boolType
      ? _value as Void
      : null;
  set boolType(Void value) {
    kind = ValueTypeKind.boolType;
    _value = value;
  }

  Void get intType => intTypeOrNull!;
  Void? get intTypeOrNull =>
    kind == ValueTypeKind.intType
      ? _value as Void
      : null;
  set intType(Void value) {
    kind = ValueTypeKind.intType;
    _value = value;
  }

  Void get doubleType => doubleTypeOrNull!;
  Void? get doubleTypeOrNull =>
    kind == ValueTypeKind.doubleType
      ? _value as Void
      : null;
  set doubleType(Void value) {
    kind = ValueTypeKind.doubleType;
    _value = value;
  }

  Void get stringType => stringTypeOrNull!;
  Void? get stringTypeOrNull =>
    kind == ValueTypeKind.stringType
      ? _value as Void
      : null;
  set stringType(Void value) {
    kind = ValueTypeKind.stringType;
    _value = value;
  }

  ClassType get classType => classTypeOrNull!;
  ClassType? get classTypeOrNull =>
    kind == ValueTypeKind.classType
      ? _value as ClassType
      : null;
  set classType(ClassType value) {
    kind = ValueTypeKind.classType;
    _value = value;
  }

  EnumType get enumType => enumTypeOrNull!;
  EnumType? get enumTypeOrNull =>
    kind == ValueTypeKind.enumType
      ? _value as EnumType
      : null;
  set enumType(EnumType value) {
    kind = ValueTypeKind.enumType;
    _value = value;
  }

  UnionType get unionType => unionTypeOrNull!;
  UnionType? get unionTypeOrNull =>
    kind == ValueTypeKind.unionType
      ? _value as UnionType
      : null;
  set unionType(UnionType value) {
    kind = ValueTypeKind.unionType;
    _value = value;
  }

  MethodType get methodType => methodTypeOrNull!;
  MethodType? get methodTypeOrNull =>
    kind == ValueTypeKind.methodType
      ? _value as MethodType
      : null;
  set methodType(MethodType value) {
    kind = ValueTypeKind.methodType;
    _value = value;
  }

  Map<String, Object?> toMap() {
    switch (kind) {
      case ValueTypeKind.optionalType:
        final $optionalType = _value as ValueType;
        return { 'optionalType': $optionalType.toMap() };
      case ValueTypeKind.boolType:
        final $boolType = _value as Void;
        return { 'boolType': $boolType.toMap() };
      case ValueTypeKind.intType:
        final $intType = _value as Void;
        return { 'intType': $intType.toMap() };
      case ValueTypeKind.doubleType:
        final $doubleType = _value as Void;
        return { 'doubleType': $doubleType.toMap() };
      case ValueTypeKind.stringType:
        final $stringType = _value as Void;
        return { 'stringType': $stringType.toMap() };
      case ValueTypeKind.classType:
        final $classType = _value as ClassType;
        return { 'classType': $classType.toMap() };
      case ValueTypeKind.enumType:
        final $enumType = _value as EnumType;
        return { 'enumType': $enumType.toMap() };
      case ValueTypeKind.unionType:
        final $unionType = _value as UnionType;
        return { 'unionType': $unionType.toMap() };
      case ValueTypeKind.methodType:
        final $methodType = _value as MethodType;
        return { 'methodType': $methodType.toMap() };
    }
  }
  @override
  int get hashCode => joFinalizeHashCode(
    joCombineHashCode(kind.hashCode, _value.hashCode),
  );

  @override
  bool operator==(Object other) {
    if (other is! ValueType) return false;
    return kind == other.kind
      && _value == other._value;
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

enum ValueKind {
  nullValue,
  boolValue,
  intValue,
  doubleValue,
  stringValue,
  listValue,
  methodValue,
  classValue,
  enumValue,
  unionValue,
}

class Value {
  Value.nullValue()
    : kind = ValueKind.nullValue,
      _value = const Void();

  Value.boolValue(bool boolValue)
    : kind = ValueKind.boolValue,
      _value = boolValue;

  Value.intValue(int intValue)
    : kind = ValueKind.intValue,
      _value = intValue;

  Value.doubleValue(double doubleValue)
    : kind = ValueKind.doubleValue,
      _value = doubleValue;

  Value.stringValue(String stringValue)
    : kind = ValueKind.stringValue,
      _value = stringValue;

  Value.listValue(List<Value> listValue)
    : kind = ValueKind.listValue,
      _value = listValue;

  Value.methodValue(MethodValue methodValue)
    : kind = ValueKind.methodValue,
      _value = methodValue;

  Value.classValue(ClassValue classValue)
    : kind = ValueKind.classValue,
      _value = classValue;

  Value.enumValue(EnumValue enumValue)
    : kind = ValueKind.enumValue,
      _value = enumValue;

  Value.unionValue(UnionValue unionValue)
    : kind = ValueKind.unionValue,
      _value = unionValue;

  ValueKind kind;
  Object _value;

  Void get nullValue => nullValueOrNull!;
  Void? get nullValueOrNull =>
    kind == ValueKind.nullValue
      ? _value as Void
      : null;
  set nullValue(Void value) {
    kind = ValueKind.nullValue;
    _value = value;
  }

  bool get boolValue => boolValueOrNull!;
  bool? get boolValueOrNull =>
    kind == ValueKind.boolValue
      ? _value as bool
      : null;
  set boolValue(bool value) {
    kind = ValueKind.boolValue;
    _value = value;
  }

  int get intValue => intValueOrNull!;
  int? get intValueOrNull =>
    kind == ValueKind.intValue
      ? _value as int
      : null;
  set intValue(int value) {
    kind = ValueKind.intValue;
    _value = value;
  }

  double get doubleValue => doubleValueOrNull!;
  double? get doubleValueOrNull =>
    kind == ValueKind.doubleValue
      ? _value as double
      : null;
  set doubleValue(double value) {
    kind = ValueKind.doubleValue;
    _value = value;
  }

  String get stringValue => stringValueOrNull!;
  String? get stringValueOrNull =>
    kind == ValueKind.stringValue
      ? _value as String
      : null;
  set stringValue(String value) {
    kind = ValueKind.stringValue;
    _value = value;
  }

  List<Value> get listValue => listValueOrNull!;
  List<Value>? get listValueOrNull =>
    kind == ValueKind.listValue
      ? _value as List<Value>
      : null;
  set listValue(List<Value> value) {
    kind = ValueKind.listValue;
    _value = value;
  }

  MethodValue get methodValue => methodValueOrNull!;
  MethodValue? get methodValueOrNull =>
    kind == ValueKind.methodValue
      ? _value as MethodValue
      : null;
  set methodValue(MethodValue value) {
    kind = ValueKind.methodValue;
    _value = value;
  }

  ClassValue get classValue => classValueOrNull!;
  ClassValue? get classValueOrNull =>
    kind == ValueKind.classValue
      ? _value as ClassValue
      : null;
  set classValue(ClassValue value) {
    kind = ValueKind.classValue;
    _value = value;
  }

  EnumValue get enumValue => enumValueOrNull!;
  EnumValue? get enumValueOrNull =>
    kind == ValueKind.enumValue
      ? _value as EnumValue
      : null;
  set enumValue(EnumValue value) {
    kind = ValueKind.enumValue;
    _value = value;
  }

  UnionValue get unionValue => unionValueOrNull!;
  UnionValue? get unionValueOrNull =>
    kind == ValueKind.unionValue
      ? _value as UnionValue
      : null;
  set unionValue(UnionValue value) {
    kind = ValueKind.unionValue;
    _value = value;
  }

  Map<String, Object?> toMap() {
    switch (kind) {
      case ValueKind.nullValue:
        final $nullValue = _value as Void;
        return { 'nullValue': $nullValue.toMap() };
      case ValueKind.boolValue:
        final $boolValue = _value as bool;
        return { 'boolValue': $boolValue };
      case ValueKind.intValue:
        final $intValue = _value as int;
        return { 'intValue': $intValue };
      case ValueKind.doubleValue:
        final $doubleValue = _value as double;
        return { 'doubleValue': $doubleValue };
      case ValueKind.stringValue:
        final $stringValue = _value as String;
        return { 'stringValue': $stringValue };
      case ValueKind.listValue:
        final $listValue = _value as List<Value>;
        return { 'listValue': $listValue.map((e) => e.toMap()).toList() };
      case ValueKind.methodValue:
        final $methodValue = _value as MethodValue;
        return { 'methodValue': $methodValue.toMap() };
      case ValueKind.classValue:
        final $classValue = _value as ClassValue;
        return { 'classValue': $classValue.toMap() };
      case ValueKind.enumValue:
        final $enumValue = _value as EnumValue;
        return { 'enumValue': $enumValue.toMap() };
      case ValueKind.unionValue:
        final $unionValue = _value as UnionValue;
        return { 'unionValue': $unionValue.toMap() };
    }
  }
  @override
  int get hashCode {
    switch (kind) {
      case ValueKind.listValue:
        return joFinalizeHashCode(
          joCombineHashCode(
            kind.hashCode,
            const ListEquality().hash(_value as List<Value>),
          ),
        );
      default:
        return joFinalizeHashCode(
          joCombineHashCode(kind.hashCode, _value.hashCode),
        );
    }
  }

  @override
  bool operator==(Object other) {
    if (other is! Value) return false;
    if (kind != other.kind) return false;
    switch (kind) {
      case ValueKind.listValue:
        return const ListEquality().equals(
          _value as List<Value>,
          other._value as List<Value>,
        );
      default:
        return _value == other._value;
    }
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

void joRegister() {}
