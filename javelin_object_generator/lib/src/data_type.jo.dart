// ** WARNING **
// This file is autogenerated by Javelin Object Compiler (joc).
// Do not edit it directly.
//
// ignore_for_file: annotate_overrides
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: directives_ordering
// ignore_for_file: prefer_const_constructors_in_immutables
// ignore_for_file: sort_constructors_first
// ignore_for_file: unused_import
import 'package:javelin_object/jo_internal.dart';

import 'token.jo.dart';
import 'void.jo.dart';

@immutable
class MapType {
  const MapType({
    required this.keyType,
    required this.valueType,
  });

  factory MapType.fromString(String s) => MapType.fromMap(fromJoText(s));

  factory MapType.fromBytes(Uint8List bytes) => MapType.fromJoFieldMap0(parseJoBinary(bytes));

  MapType.fromJoFieldMap0(Map<int, JoFieldData> map)
    : keyType = _keyTypeFromJoFieldMap(map),
      valueType = _valueTypeFromJoFieldMap(map);

  MapType.fromMap(Map<Object?, Object?> map)
    : keyType = _keyTypeFromMap(map),
      valueType = _valueTypeFromMap(map);

  final DataType keyType;
  final DataType valueType;

  Uint8List toBytes() => encodeBytes().toBytes();

  JoBinaryEncoder encodeBytes([JoBinaryEncoder? $derivedEncoder]) {
    final encoder = JoBinaryEncoder();
    final $keyTypeEncoder = JoBinaryEncoder();
    keyType.encodeBytes($keyTypeEncoder);
    encoder.writeObject(0, $keyTypeEncoder);
    final $valueTypeEncoder = JoBinaryEncoder();
    valueType.encodeBytes($valueTypeEncoder);
    encoder.writeObject(1, $valueTypeEncoder);
    return encoder;
  }

  Map<String, Object?> toMap() {
    final $keyType = keyType;
    final $valueType = valueType;

    return {
      'keyType': $keyType.toMap(),
      'valueType': $valueType.toMap(),
    };
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static DataType _keyTypeFromJoFieldMap(Map<int, JoFieldData> map) {
    final $keyType = map.bytesValue(0);
    return DataType.fromBytes($keyType!);
  }
  static DataType _valueTypeFromJoFieldMap(Map<int, JoFieldData> map) {
    final $valueType = map.bytesValue(1);
    return DataType.fromBytes($valueType!);
  }

  static DataType _keyTypeFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<Map>(fieldName: 'keyType');
    return DataType.fromMapOrNull(lookup)!;
  }
  static DataType _valueTypeFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<Map>(fieldName: 'valueType');
    return DataType.fromMapOrNull(lookup)!;
  }
}

@immutable
class ObjectType {
  const ObjectType({
    required this.token,
    required this.objectName,
  });

  factory ObjectType.fromString(String s) => ObjectType.fromMap(fromJoText(s));

  factory ObjectType.fromBytes(Uint8List bytes) => ObjectType.fromJoFieldMap0(parseJoBinary(bytes));

  ObjectType.fromJoFieldMap0(Map<int, JoFieldData> map)
    : token = _tokenFromJoFieldMap(map),
      objectName = _objectNameFromJoFieldMap(map);

  ObjectType.fromMap(Map<Object?, Object?> map)
    : token = _tokenFromMap(map),
      objectName = _objectNameFromMap(map);

  final Token token;
  final String objectName;

  Uint8List toBytes([bool $includeType=false]) =>
    encodeBytes(null, $includeType).toBytes();

  JoBinaryEncoder encodeBytes([
    JoBinaryEncoder? $derivedEncoder,
    bool $includeType=false,
  ]) {
    final encoder = JoBinaryEncoder();
    if ($derivedEncoder != null) {
      encoder.writeObject(0, $derivedEncoder);
    }
    encoder.writeObject(1, token.encodeBytes());
    encoder.writeString(2, objectName);
    return encoder;
  }

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $token = token;
    final $objectName = objectName;

    return {
      'token': $token.toMap(),
      'objectName': $objectName,
    };
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static Token _tokenFromJoFieldMap(Map<int, JoFieldData> map) {
    final $token = map.bytesValue(1);
    return Token.fromBytes($token!);
  }
  static String _objectNameFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.stringValue(2)!;

  static Token _tokenFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<Map>(fieldName: 'token');
    return Token.fromMap(lookup);
  }
  static String _objectNameFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String>(fieldName: 'objectName');
}

@immutable
class ClassType extends ObjectType {
  const ClassType({
    required Token token,
    required String objectName,
  })  : super(
         token: token,
         objectName: objectName,
       );

  factory ClassType.fromString(String s) => ClassType.fromMap(fromJoText(s));

  factory ClassType.fromBytes(Uint8List bytes) => ClassType.fromJoFieldMap0(parseJoBinary(bytes));

  ClassType.fromJoFieldMap0(Map<int, JoFieldData> map0) : this.fromJoFieldMap1(map0, map0.embeddedObject(0) ?? const {});
  ClassType.fromJoFieldMap1(Map<int, JoFieldData> map0, Map<int, JoFieldData> map)
    : super.fromJoFieldMap0(map0);

  ClassType.fromMap(Map<Object?, Object?> map)
    : super.fromMap(map);

  Uint8List toBytes([bool $includeType=false]) =>
    encodeBytes(null, $includeType).toBytes();

  JoBinaryEncoder encodeBytes([
    JoBinaryEncoder? $derivedEncoder,
    bool $includeType=false,
  ]) {
    final encoder = JoBinaryEncoder();
    return super.encodeBytes(encoder, $includeType);
  }


  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

}

enum DataTypeKind {
  optionalType,
  boolType,
  int8Type,
  int32Type,
  int64Type,
  uint8Type,
  uint32Type,
  uint64Type,
  floatType,
  doubleType,
  stringType,
  bytesType,
  listType,
  setType,
  mapType,
  objectType,
}

@immutable
class DataType {
  const DataType.optionalType(DataType optionalType)
    : kind = DataTypeKind.optionalType,
      _value = optionalType;

  const DataType.boolType()
    : kind = DataTypeKind.boolType,
      _value = const Void();

  const DataType.int8Type()
    : kind = DataTypeKind.int8Type,
      _value = const Void();

  const DataType.int32Type()
    : kind = DataTypeKind.int32Type,
      _value = const Void();

  const DataType.int64Type()
    : kind = DataTypeKind.int64Type,
      _value = const Void();

  const DataType.uint8Type()
    : kind = DataTypeKind.uint8Type,
      _value = const Void();

  const DataType.uint32Type()
    : kind = DataTypeKind.uint32Type,
      _value = const Void();

  const DataType.uint64Type()
    : kind = DataTypeKind.uint64Type,
      _value = const Void();

  const DataType.floatType()
    : kind = DataTypeKind.floatType,
      _value = const Void();

  const DataType.doubleType()
    : kind = DataTypeKind.doubleType,
      _value = const Void();

  const DataType.stringType()
    : kind = DataTypeKind.stringType,
      _value = const Void();

  const DataType.bytesType()
    : kind = DataTypeKind.bytesType,
      _value = const Void();

  const DataType.listType(DataType listType)
    : kind = DataTypeKind.listType,
      _value = listType;

  const DataType.setType(DataType setType)
    : kind = DataTypeKind.setType,
      _value = setType;

  const DataType.mapType(MapType mapType)
    : kind = DataTypeKind.mapType,
      _value = mapType;

  const DataType.objectType(ObjectType objectType)
    : kind = DataTypeKind.objectType,
      _value = objectType;

  static DataType? fromMapOrNull(Map<Object?, Object?> map) {
    final entries = map.entries;
    if (entries.length != 1) return null;
    final entry = entries.first;
    switch (entry.key) {
      case 'optionalType':
        return _optionalTypeFromValue(entry.value);
      case 'boolType':
        return _boolTypeFromValue(entry.value);
      case 'int8Type':
        return _int8TypeFromValue(entry.value);
      case 'int32Type':
        return _int32TypeFromValue(entry.value);
      case 'int64Type':
        return _int64TypeFromValue(entry.value);
      case 'uint8Type':
        return _uint8TypeFromValue(entry.value);
      case 'uint32Type':
        return _uint32TypeFromValue(entry.value);
      case 'uint64Type':
        return _uint64TypeFromValue(entry.value);
      case 'floatType':
        return _floatTypeFromValue(entry.value);
      case 'doubleType':
        return _doubleTypeFromValue(entry.value);
      case 'stringType':
        return _stringTypeFromValue(entry.value);
      case 'bytesType':
        return _bytesTypeFromValue(entry.value);
      case 'listType':
        return _listTypeFromValue(entry.value);
      case 'setType':
        return _setTypeFromValue(entry.value);
      case 'mapType':
        return _mapTypeFromValue(entry.value);
      case 'objectType':
        return _objectTypeFromValue(entry.value);
      default:
        return null;
    }
  }

  factory DataType.fromBytes(Uint8List bytes) =>
    DataType.fromJoFieldMapOrNull(parseJoBinary(bytes))!;

  static DataType? fromJoFieldMapOrNull(Map<int, JoFieldData> map) {
    final entries = map.entries;
    if (entries.length != 1) return null;
    final entry = entries.first;
    switch (entry.key) {
      case 0:
        return _optionalTypeFromJoField(entry.value);
      case 1:
        return _boolTypeFromJoField();
      case 2:
        return _int8TypeFromJoField();
      case 3:
        return _int32TypeFromJoField();
      case 4:
        return _int64TypeFromJoField();
      case 5:
        return _uint8TypeFromJoField();
      case 6:
        return _uint32TypeFromJoField();
      case 7:
        return _uint64TypeFromJoField();
      case 8:
        return _floatTypeFromJoField();
      case 9:
        return _doubleTypeFromJoField();
      case 10:
        return _stringTypeFromJoField();
      case 11:
        return _bytesTypeFromJoField();
      case 12:
        return _listTypeFromJoField(entry.value);
      case 13:
        return _setTypeFromJoField(entry.value);
      case 14:
        return _mapTypeFromJoField(entry.value);
      case 15:
        return _objectTypeFromJoField(entry.value);
      default:
        return null;
    }
  }

  factory DataType.fromString(String s) =>
    DataType.fromMapOrNull(fromJoText(s))!;

  T when<T>({
    required T Function(DataType) optionalType,
    required T Function() boolType,
    required T Function() int8Type,
    required T Function() int32Type,
    required T Function() int64Type,
    required T Function() uint8Type,
    required T Function() uint32Type,
    required T Function() uint64Type,
    required T Function() floatType,
    required T Function() doubleType,
    required T Function() stringType,
    required T Function() bytesType,
    required T Function(DataType) listType,
    required T Function(DataType) setType,
    required T Function(MapType) mapType,
    required T Function(ObjectType) objectType,
  }) {
    switch (kind) {
      case DataTypeKind.optionalType:
        return optionalType(_value as DataType);
      case DataTypeKind.boolType:
        return boolType();
      case DataTypeKind.int8Type:
        return int8Type();
      case DataTypeKind.int32Type:
        return int32Type();
      case DataTypeKind.int64Type:
        return int64Type();
      case DataTypeKind.uint8Type:
        return uint8Type();
      case DataTypeKind.uint32Type:
        return uint32Type();
      case DataTypeKind.uint64Type:
        return uint64Type();
      case DataTypeKind.floatType:
        return floatType();
      case DataTypeKind.doubleType:
        return doubleType();
      case DataTypeKind.stringType:
        return stringType();
      case DataTypeKind.bytesType:
        return bytesType();
      case DataTypeKind.listType:
        return listType(_value as DataType);
      case DataTypeKind.setType:
        return setType(_value as DataType);
      case DataTypeKind.mapType:
        return mapType(_value as MapType);
      case DataTypeKind.objectType:
        return objectType(_value as ObjectType);
    }
  }

  final DataTypeKind kind;
  final Object _value;

  DataType get optionalType => optionalTypeOrNull!;
  DataType? get optionalTypeOrNull =>
    kind == DataTypeKind.optionalType
      ? _value as DataType
      : null;

  Void get boolType => boolTypeOrNull!;
  Void? get boolTypeOrNull =>
    kind == DataTypeKind.boolType
      ? _value as Void
      : null;

  Void get int8Type => int8TypeOrNull!;
  Void? get int8TypeOrNull =>
    kind == DataTypeKind.int8Type
      ? _value as Void
      : null;

  Void get int32Type => int32TypeOrNull!;
  Void? get int32TypeOrNull =>
    kind == DataTypeKind.int32Type
      ? _value as Void
      : null;

  Void get int64Type => int64TypeOrNull!;
  Void? get int64TypeOrNull =>
    kind == DataTypeKind.int64Type
      ? _value as Void
      : null;

  Void get uint8Type => uint8TypeOrNull!;
  Void? get uint8TypeOrNull =>
    kind == DataTypeKind.uint8Type
      ? _value as Void
      : null;

  Void get uint32Type => uint32TypeOrNull!;
  Void? get uint32TypeOrNull =>
    kind == DataTypeKind.uint32Type
      ? _value as Void
      : null;

  Void get uint64Type => uint64TypeOrNull!;
  Void? get uint64TypeOrNull =>
    kind == DataTypeKind.uint64Type
      ? _value as Void
      : null;

  Void get floatType => floatTypeOrNull!;
  Void? get floatTypeOrNull =>
    kind == DataTypeKind.floatType
      ? _value as Void
      : null;

  Void get doubleType => doubleTypeOrNull!;
  Void? get doubleTypeOrNull =>
    kind == DataTypeKind.doubleType
      ? _value as Void
      : null;

  Void get stringType => stringTypeOrNull!;
  Void? get stringTypeOrNull =>
    kind == DataTypeKind.stringType
      ? _value as Void
      : null;

  Void get bytesType => bytesTypeOrNull!;
  Void? get bytesTypeOrNull =>
    kind == DataTypeKind.bytesType
      ? _value as Void
      : null;

  DataType get listType => listTypeOrNull!;
  DataType? get listTypeOrNull =>
    kind == DataTypeKind.listType
      ? _value as DataType
      : null;

  DataType get setType => setTypeOrNull!;
  DataType? get setTypeOrNull =>
    kind == DataTypeKind.setType
      ? _value as DataType
      : null;

  MapType get mapType => mapTypeOrNull!;
  MapType? get mapTypeOrNull =>
    kind == DataTypeKind.mapType
      ? _value as MapType
      : null;

  ObjectType get objectType => objectTypeOrNull!;
  ObjectType? get objectTypeOrNull =>
    kind == DataTypeKind.objectType
      ? _value as ObjectType
      : null;

  Uint8List toBytes() {
    final encoder = JoBinaryEncoder();
    encodeBytes(encoder);
    return encoder.toBytes();
  }

  void encodeBytes(JoBinaryEncoder encoder) {
    switch (kind) {
     case DataTypeKind.optionalType:
       final $optionalTypeEncoder = JoBinaryEncoder();
       optionalType.encodeBytes($optionalTypeEncoder);
       encoder.writeObject(0, $optionalTypeEncoder);
       break;
     case DataTypeKind.boolType:
       encoder.writeObject(1, boolType.encodeBytes());
       break;
     case DataTypeKind.int8Type:
       encoder.writeObject(2, int8Type.encodeBytes());
       break;
     case DataTypeKind.int32Type:
       encoder.writeObject(3, int32Type.encodeBytes());
       break;
     case DataTypeKind.int64Type:
       encoder.writeObject(4, int64Type.encodeBytes());
       break;
     case DataTypeKind.uint8Type:
       encoder.writeObject(5, uint8Type.encodeBytes());
       break;
     case DataTypeKind.uint32Type:
       encoder.writeObject(6, uint32Type.encodeBytes());
       break;
     case DataTypeKind.uint64Type:
       encoder.writeObject(7, uint64Type.encodeBytes());
       break;
     case DataTypeKind.floatType:
       encoder.writeObject(8, floatType.encodeBytes());
       break;
     case DataTypeKind.doubleType:
       encoder.writeObject(9, doubleType.encodeBytes());
       break;
     case DataTypeKind.stringType:
       encoder.writeObject(10, stringType.encodeBytes());
       break;
     case DataTypeKind.bytesType:
       encoder.writeObject(11, bytesType.encodeBytes());
       break;
     case DataTypeKind.listType:
       final $listTypeEncoder = JoBinaryEncoder();
       listType.encodeBytes($listTypeEncoder);
       encoder.writeObject(12, $listTypeEncoder);
       break;
     case DataTypeKind.setType:
       final $setTypeEncoder = JoBinaryEncoder();
       setType.encodeBytes($setTypeEncoder);
       encoder.writeObject(13, $setTypeEncoder);
       break;
     case DataTypeKind.mapType:
       encoder.writeObject(14, mapType.encodeBytes());
       break;
     case DataTypeKind.objectType:
       encoder.writeObject(15, objectType.encodeBytes(null, false));
       break;
    }
  }

  Map<String, Object?> toMap() {
    switch (kind) {
      case DataTypeKind.optionalType:
        final $optionalType = _value as DataType;
        return { 'optionalType': $optionalType.toMap() };
      case DataTypeKind.boolType:
        final $boolType = _value as Void;
        return { 'boolType': $boolType.toMap() };
      case DataTypeKind.int8Type:
        final $int8Type = _value as Void;
        return { 'int8Type': $int8Type.toMap() };
      case DataTypeKind.int32Type:
        final $int32Type = _value as Void;
        return { 'int32Type': $int32Type.toMap() };
      case DataTypeKind.int64Type:
        final $int64Type = _value as Void;
        return { 'int64Type': $int64Type.toMap() };
      case DataTypeKind.uint8Type:
        final $uint8Type = _value as Void;
        return { 'uint8Type': $uint8Type.toMap() };
      case DataTypeKind.uint32Type:
        final $uint32Type = _value as Void;
        return { 'uint32Type': $uint32Type.toMap() };
      case DataTypeKind.uint64Type:
        final $uint64Type = _value as Void;
        return { 'uint64Type': $uint64Type.toMap() };
      case DataTypeKind.floatType:
        final $floatType = _value as Void;
        return { 'floatType': $floatType.toMap() };
      case DataTypeKind.doubleType:
        final $doubleType = _value as Void;
        return { 'doubleType': $doubleType.toMap() };
      case DataTypeKind.stringType:
        final $stringType = _value as Void;
        return { 'stringType': $stringType.toMap() };
      case DataTypeKind.bytesType:
        final $bytesType = _value as Void;
        return { 'bytesType': $bytesType.toMap() };
      case DataTypeKind.listType:
        final $listType = _value as DataType;
        return { 'listType': $listType.toMap() };
      case DataTypeKind.setType:
        final $setType = _value as DataType;
        return { 'setType': $setType.toMap() };
      case DataTypeKind.mapType:
        final $mapType = _value as MapType;
        return { 'mapType': $mapType.toMap() };
      case DataTypeKind.objectType:
        final $objectType = _value as ObjectType;
        return { 'objectType': $objectType.toMap(false) };
    }
  }
  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static DataType? _optionalTypeFromValue(Object? value) {
    if (value is! Map) return null;
    final unionValue = DataType.fromMapOrNull(value);
    if (unionValue == null) return null;
    return DataType.optionalType(unionValue);
   }
  static DataType _boolTypeFromValue(Object? value) =>
    const DataType.boolType();
  static DataType _int8TypeFromValue(Object? value) =>
    const DataType.int8Type();
  static DataType _int32TypeFromValue(Object? value) =>
    const DataType.int32Type();
  static DataType _int64TypeFromValue(Object? value) =>
    const DataType.int64Type();
  static DataType _uint8TypeFromValue(Object? value) =>
    const DataType.uint8Type();
  static DataType _uint32TypeFromValue(Object? value) =>
    const DataType.uint32Type();
  static DataType _uint64TypeFromValue(Object? value) =>
    const DataType.uint64Type();
  static DataType _floatTypeFromValue(Object? value) =>
    const DataType.floatType();
  static DataType _doubleTypeFromValue(Object? value) =>
    const DataType.doubleType();
  static DataType _stringTypeFromValue(Object? value) =>
    const DataType.stringType();
  static DataType _bytesTypeFromValue(Object? value) =>
    const DataType.bytesType();
  static DataType? _listTypeFromValue(Object? value) {
    if (value is! Map) return null;
    final unionValue = DataType.fromMapOrNull(value);
    if (unionValue == null) return null;
    return DataType.listType(unionValue);
   }
  static DataType? _setTypeFromValue(Object? value) {
    if (value is! Map) return null;
    final unionValue = DataType.fromMapOrNull(value);
    if (unionValue == null) return null;
    return DataType.setType(unionValue);
   }
  static DataType _mapTypeFromValue(Object? value) =>
    DataType.mapType(MapType.fromMap(value as Map));
  static DataType _objectTypeFromValue(Object? value) =>
    DataType.objectType(ObjectType.fromMap(value as Map));

  static DataType? _optionalTypeFromJoField(JoFieldData data) {
    final result = DataType.fromJoFieldMapOrNull(data.embeddedObject);
    if (result == null) return null;
    return DataType.optionalType(result);
  }
  static DataType _boolTypeFromJoField() =>
    const DataType.boolType();
  static DataType _int8TypeFromJoField() =>
    const DataType.int8Type();
  static DataType _int32TypeFromJoField() =>
    const DataType.int32Type();
  static DataType _int64TypeFromJoField() =>
    const DataType.int64Type();
  static DataType _uint8TypeFromJoField() =>
    const DataType.uint8Type();
  static DataType _uint32TypeFromJoField() =>
    const DataType.uint32Type();
  static DataType _uint64TypeFromJoField() =>
    const DataType.uint64Type();
  static DataType _floatTypeFromJoField() =>
    const DataType.floatType();
  static DataType _doubleTypeFromJoField() =>
    const DataType.doubleType();
  static DataType _stringTypeFromJoField() =>
    const DataType.stringType();
  static DataType _bytesTypeFromJoField() =>
    const DataType.bytesType();
  static DataType? _listTypeFromJoField(JoFieldData data) {
    final result = DataType.fromJoFieldMapOrNull(data.embeddedObject);
    if (result == null) return null;
    return DataType.listType(result);
  }
  static DataType? _setTypeFromJoField(JoFieldData data) {
    final result = DataType.fromJoFieldMapOrNull(data.embeddedObject);
    if (result == null) return null;
    return DataType.setType(result);
  }
  static DataType _mapTypeFromJoField(JoFieldData data) =>
    DataType.mapType(MapType.fromJoFieldMap0(data.embeddedObject));
  static DataType _objectTypeFromJoField(JoFieldData data) =>
    DataType.objectType(ObjectType.fromJoFieldMap0(data.embeddedObject));
}

void joRegister() {}
