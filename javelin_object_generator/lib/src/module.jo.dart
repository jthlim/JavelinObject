// ** WARNING **
// This file is autogenerated by Javelin Object Compiler (joc).
// Do not edit it directly.
//
// ignore_for_file: annotate_overrides
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: directives_ordering
// ignore_for_file: prefer_const_constructors_in_immutables
// ignore_for_file: sort_constructors_first
// ignore_for_file: unused_import
import 'package:javelin_object/jo_internal.dart';

import 'data_type.jo.dart';
import 'token.jo.dart';
import 'value.jo.dart';
import 'void.jo.dart';

class Annotation {
  Annotation({
    required this.name,
    required this.parameters,
  });

  factory Annotation.fromString(String s) => Annotation.fromMap(fromJoText(s));

  factory Annotation.fromBytes(Uint8List bytes) => Annotation.fromJoFieldMap0(parseJoBinary(bytes));

  Annotation.fromJoFieldMap0(Map<int, JoFieldData> map)
    : name = _nameFromJoFieldMap(map),
      parameters = _parametersFromJoFieldMap(map);

  Annotation.fromMap(Map<Object?, Object?> map)
    : name = _nameFromMap(map),
      parameters = _parametersFromMap(map);

  String name;
  Map<String, Value> parameters;

  Uint8List toBytes() => encodeBytes().toBytes();

  JoBinaryEncoder encodeBytes([JoBinaryEncoder? $derivedEncoder]) {
    final encoder = JoBinaryEncoder();
    encoder.writeString(0, name);
    encoder.writeMap<String, Value>(1, parameters, (enc, e) => enc.writeString(e), (enc, e) {
        final objectEncoder = JoBinaryEncoder();
        e.encodeBytes(objectEncoder);
        enc.writeObject(objectEncoder);
      });
    return encoder;
  }

  Map<String, Object?> toMap() {
    final $name = name;
    final $parameters = parameters;

    return {
      'name': $name,
      'parameters': $parameters.map((k, v) => MapEntry(k, v.toMap())),
    };
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static String _nameFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.stringValue(0)!;
  static Map<String, Value> _parametersFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.mapValue(1, (fieldData) => fieldData.stringValue, (fieldData) => Value.fromJoFieldMapOrNull(fieldData.embeddedObject), false)!;

  static String _nameFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String>(fieldName: 'name');
  static Map<String, Value> _parametersFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<Map>(fieldName: 'parameters');
    return lookup.joMapNotNull((k) => k as String, (v) => Value.fromMapOrNull(v as Map));
  }
}

/// A module represents a single .jo file.
class Module {
  Module({
    required this.filename,
    Package? package,
    List<Module>? imports,
    List<Class>? classes,
    List<Union>? unions,
    List<Enum>? enums,
  })  : package = package ?? Package(),
       imports = imports ?? [],
       classes = classes ?? [],
       unions = unions ?? [],
       enums = enums ?? [];

  factory Module.fromString(String s) => Module.fromMap(fromJoText(s));

  factory Module.fromBytes(Uint8List bytes) => Module.fromJoFieldMap0(parseJoBinary(bytes));

  Module.fromJoFieldMap0(Map<int, JoFieldData> map)
    : filename = _filenameFromJoFieldMap(map),
      package = _packageFromJoFieldMap(map),
      imports = _importsFromJoFieldMap(map),
      classes = _classesFromJoFieldMap(map),
      unions = _unionsFromJoFieldMap(map),
      enums = _enumsFromJoFieldMap(map);

  Module.fromMap(Map<Object?, Object?> map)
    : filename = _filenameFromMap(map),
      package = _packageFromMap(map),
      imports = _importsFromMap(map),
      classes = _classesFromMap(map),
      unions = _unionsFromMap(map),
      enums = _enumsFromMap(map);

  String filename;
  Package package;
  List<Module> imports;
  List<Class> classes;
  List<Union> unions;
  List<Enum> enums;

  Uint8List toBytes() => encodeBytes().toBytes();

  JoBinaryEncoder encodeBytes([JoBinaryEncoder? $derivedEncoder]) {
    final encoder = JoBinaryEncoder();
    encoder.writeString(0, filename);
    encoder.writeObject(1, package.encodeBytes());
    encoder.writeIterable<Module>(2, imports, (enc, e) => enc.writeObject(e.encodeBytes()));
    encoder.writeIterable<Class>(3, classes, (enc, e) => enc.writeObject(e.encodeBytes()));
    encoder.writeIterable<Union>(4, unions, (enc, e) => enc.writeObject(e.encodeBytes()));
    encoder.writeIterable<Enum>(5, enums, (enc, e) => enc.writeObject(e.encodeBytes()));
    return encoder;
  }

  Map<String, Object?> toMap() {
    final $filename = filename;
    final $package = package;
    final $imports = imports;
    final $classes = classes;
    final $unions = unions;
    final $enums = enums;

    return {
      'filename': $filename,
      'package': $package.toMap(),
      'imports': $imports.map((e) => e.toMap()).toList(),
      'classes': $classes.map((e) => e.toMap()).toList(),
      'unions': $unions.map((e) => e.toMap()).toList(),
      'enums': $enums.map((e) => e.toMap()).toList(),
    };
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static String _filenameFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.stringValue(0)!;
  static Package _packageFromJoFieldMap(Map<int, JoFieldData> map) {
    final $package = map.bytesValue(1);
    if ($package == null) return Package();
    return Package.fromBytes($package);
  }
  static List<Module> _importsFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.listValue(2, (fieldData) => Module.fromJoFieldMap0(fieldData.embeddedObject), false)!;
  static List<Class> _classesFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.listValue(3, (fieldData) => Class.fromJoFieldMap0(fieldData.embeddedObject), false)!;
  static List<Union> _unionsFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.listValue(4, (fieldData) => Union.fromJoFieldMap0(fieldData.embeddedObject), false)!;
  static List<Enum> _enumsFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.listValue(5, (fieldData) => Enum.fromJoFieldMap0(fieldData.embeddedObject), false)!;

  static String _filenameFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String>(fieldName: 'filename');
  static Package _packageFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<Map?>(fieldName: 'package');
    if (lookup == null) return Package();
    return Package.fromMap(lookup);
  }
  static List<Module> _importsFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List?>(fieldName: 'imports');
    if (lookup == null) return [];
    return lookup.joMapNotNull((e) => Module.fromMap(e as Map)).toList();
  }
  static List<Class> _classesFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List?>(fieldName: 'classes');
    if (lookup == null) return [];
    return lookup.joMapNotNull((e) => Class.fromMap(e as Map)).toList();
  }
  static List<Union> _unionsFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List?>(fieldName: 'unions');
    if (lookup == null) return [];
    return lookup.joMapNotNull((e) => Union.fromMap(e as Map)).toList();
  }
  static List<Enum> _enumsFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List?>(fieldName: 'enums');
    if (lookup == null) return [];
    return lookup.joMapNotNull((e) => Enum.fromMap(e as Map)).toList();
  }
}

class Package {
  Package({
    this.packageParts = const [],
    List<Annotation>? annotations,
  })  : annotations = annotations ?? [];

  factory Package.fromString(String s) => Package.fromMap(fromJoText(s));

  factory Package.fromBytes(Uint8List bytes) => Package.fromJoFieldMap0(parseJoBinary(bytes));

  Package.fromJoFieldMap0(Map<int, JoFieldData> map)
    : packageParts = _packagePartsFromJoFieldMap(map),
      annotations = _annotationsFromJoFieldMap(map);

  Package.fromMap(Map<Object?, Object?> map)
    : packageParts = _packagePartsFromMap(map),
      annotations = _annotationsFromMap(map);


  /// The parts of the package name.
  ///
  /// e.g. au.com.lim.type would be ['au', 'com', 'lim', 'type'].
  List<String> packageParts;
  List<Annotation> annotations;

  Uint8List toBytes() => encodeBytes().toBytes();

  JoBinaryEncoder encodeBytes([JoBinaryEncoder? $derivedEncoder]) {
    final encoder = JoBinaryEncoder();
    encoder.writeIterable<String>(1, packageParts, (enc, e) => enc.writeString(e));
    encoder.writeIterable<Annotation>(2, annotations, (enc, e) => enc.writeObject(e.encodeBytes()));
    return encoder;
  }

  Map<String, Object?> toMap() {
    final $packageParts = packageParts;
    final $annotations = annotations;

    return {
      'packageParts': $packageParts,
      'annotations': $annotations.map((e) => e.toMap()).toList(),
    };
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static List<String> _packagePartsFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.listValue(1, (fieldData) => fieldData.stringValue, false)!;
  static List<Annotation> _annotationsFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.listValue(2, (fieldData) => Annotation.fromJoFieldMap0(fieldData.embeddedObject), false)!;

  static List<String> _packagePartsFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List?>(fieldName: 'packageParts');
    if (lookup == null) return const [];
    return lookup.joMapNotNull((e) => e as String).toList();
  }
  static List<Annotation> _annotationsFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List?>(fieldName: 'annotations');
    if (lookup == null) return [];
    return lookup.joMapNotNull((e) => Annotation.fromMap(e as Map)).toList();
  }
}

/// Base class for [Class]es, [Union]s and [Enum]s.
abstract class ObjectBase {
  @protected
  ObjectBase({
    required this.name,
    required this.nameToken,
    required this.annotations,
    List<String>? documentationComments,
    List<Field>? fields,
  })  : _documentationComments = documentationComments,
       fields = fields ?? [];

  @protected
  ObjectBase.fromJoFieldMap0(Map<int, JoFieldData> map)
    : name = _nameFromJoFieldMap(map),
      nameToken = _nameTokenFromJoFieldMap(map),
      annotations = _annotationsFromJoFieldMap(map),
      _documentationComments = _documentationCommentsFromJoFieldMap(map),
      fields = _fieldsFromJoFieldMap(map);

  @protected
  ObjectBase.fromMap(Map<Object?, Object?> map)
    : name = _nameFromMap(map),
      nameToken = _nameTokenFromMap(map),
      annotations = _annotationsFromMap(map),
      _documentationComments = _documentationCommentsFromMap(map),
      fields = _fieldsFromMap(map);

  String name;
  Token nameToken;
  List<Annotation> annotations;
  List<String> get documentationComments => _documentationComments ?? const [];
  List<String>? _documentationComments;
  set documentationComments(List<String>? $value) => _documentationComments = $value;
  List<Field> fields;

  Uint8List toBytes([bool $includeType=false]) =>
    encodeBytes(null, $includeType).toBytes();

  JoBinaryEncoder encodeBytes([
    JoBinaryEncoder? $derivedEncoder,
    bool $includeType=false,
  ]) {
    final encoder = JoBinaryEncoder();
    if ($derivedEncoder != null) {
      encoder.writeObject(0, $derivedEncoder);
    }
    encoder.writeString(1, name);
    encoder.writeObject(2, nameToken.encodeBytes());
    encoder.writeIterable<Annotation>(3, annotations, (enc, e) => enc.writeObject(e.encodeBytes()));
    final $documentationComments = _documentationComments;
    if ($documentationComments != null) {
      encoder.writeIterable<String>(4, $documentationComments, (enc, e) => enc.writeString(e));
    }
    encoder.writeIterable<Field>(5, fields, (enc, e) => enc.writeObject(e.encodeBytes()));
    return encoder;
  }

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $name = name;
    final $nameToken = nameToken;
    final $annotations = annotations;
    final $documentationComments = _documentationComments;
    final $fields = fields;

    return {
      'name': $name,
      'nameToken': $nameToken.toMap(),
      'annotations': $annotations.map((e) => e.toMap()).toList(),
      if ($documentationComments != null)
        'documentationComments': $documentationComments,
      'fields': $fields.map((e) => e.toMap()).toList(),
    };
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static String _nameFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.stringValue(1)!;
  static Token _nameTokenFromJoFieldMap(Map<int, JoFieldData> map) {
    final $nameToken = map.bytesValue(2);
    return Token.fromBytes($nameToken!);
  }
  static List<Annotation> _annotationsFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.listValue(3, (fieldData) => Annotation.fromJoFieldMap0(fieldData.embeddedObject), false)!;
  static List<String>? _documentationCommentsFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.listValue(4, (fieldData) => fieldData.stringValue, false);
  static List<Field> _fieldsFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.listValue(5, (fieldData) => Field.fromJoFieldMap0(fieldData.embeddedObject), false)!;

  static String _nameFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String>(fieldName: 'name');
  static Token _nameTokenFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<Map>(fieldName: 'nameToken');
    return Token.fromMap(lookup);
  }
  static List<Annotation> _annotationsFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List>(fieldName: 'annotations');
    return lookup.joMapNotNull((e) => Annotation.fromMap(e as Map)).toList();
  }
  static List<String>? _documentationCommentsFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List?>(fieldName: 'documentationComments');
    if (lookup == null) return null;
    return lookup.joMapNotNull((e) => e as String).toList();
  }
  static List<Field> _fieldsFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List?>(fieldName: 'fields');
    if (lookup == null) return [];
    return lookup.joMapNotNull((e) => Field.fromMap(e as Map)).toList();
  }
}

class Class extends ObjectBase {
  Class({
    required String name,
    required Token nameToken,
    required List<Annotation> annotations,
    List<String>? documentationComments,
    List<Field>? fields,
    this.baseClass,
    required this.isVirtual,
    required this.isExtendable,
    List<Method>? methods,
  })  : methods = methods ?? [],
       super(
         name: name,
         nameToken: nameToken,
         annotations: annotations,
         documentationComments: documentationComments,
         fields: fields,
       );

  factory Class.fromString(String s) => Class.fromMap(fromJoText(s));

  factory Class.fromBytes(Uint8List bytes) => Class.fromJoFieldMap0(parseJoBinary(bytes));

  Class.fromJoFieldMap0(Map<int, JoFieldData> map0) : this.fromJoFieldMap1(map0, map0.embeddedObject(0) ?? const {});
  Class.fromJoFieldMap1(Map<int, JoFieldData> map0, Map<int, JoFieldData> map)
    : baseClass = _baseClassFromJoFieldMap(map),
      isVirtual = _isVirtualFromJoFieldMap(map),
      isExtendable = _isExtendableFromJoFieldMap(map),
      methods = _methodsFromJoFieldMap(map),
      super.fromJoFieldMap0(map0);

  Class.fromMap(Map<Object?, Object?> map)
    : baseClass = _baseClassFromMap(map),
      isVirtual = _isVirtualFromMap(map),
      isExtendable = _isExtendableFromMap(map),
      methods = _methodsFromMap(map),
      super.fromMap(map);

  ClassType? baseClass;

  /// Whether the class has a dynamic factory.
  ///
  /// A class that is virtual will encode its type when serialized.
  ///
  /// Example:
  ///   extendable class Base;
  ///   class Derived extends Base;
  ///
  ///   class Test {
  ///      Base b;           // Will encode type.
  ///      Derived d;        // Will not encode type.
  ///      List<Base> lb;    // Will encode type for each element.
  ///      List<Derived> ld; // Will not encode type for each element.
  ///   }
  ///
  /// isVirtual implies [isExtendable].
  bool isVirtual;

  /// Whether the class can have child classes.
  bool isExtendable;
  List<Method> methods;

  Uint8List toBytes([bool $includeType=false]) =>
    encodeBytes(null, $includeType).toBytes();

  JoBinaryEncoder encodeBytes([
    JoBinaryEncoder? $derivedEncoder,
    bool $includeType=false,
  ]) {
    final encoder = JoBinaryEncoder();
    final $baseClass = baseClass;
    if ($baseClass != null) {
      encoder.writeObject(1, $baseClass.encodeBytes());
    }
    encoder.writeBool(2, isVirtual);
    encoder.writeBool(3, isExtendable);
    encoder.writeIterable<Method>(4, methods, (enc, e) => enc.writeObject(e.encodeBytes()));
    return super.encodeBytes(encoder, $includeType);
  }

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $baseClass = baseClass;
    final $isVirtual = isVirtual;
    final $isExtendable = isExtendable;
    final $methods = methods;

    final $$result = super.toMap();
    if ($baseClass != null) $$result['baseClass'] = $baseClass.toMap();
    $$result['isVirtual'] = $isVirtual;
    $$result['isExtendable'] = $isExtendable;
    $$result['methods'] = $methods.map((e) => e.toMap()).toList();
    return $$result;
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static ClassType? _baseClassFromJoFieldMap(Map<int, JoFieldData> map) {
    final $baseClass = map.bytesValue(1);
    if ($baseClass == null) return null;
    return ClassType.fromBytes($baseClass);
  }
  static bool _isVirtualFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.boolValue(2)!;
  static bool _isExtendableFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.boolValue(3)!;
  static List<Method> _methodsFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.listValue(4, (fieldData) => Method.fromJoFieldMap0(fieldData.embeddedObject), false)!;

  static ClassType? _baseClassFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<Map?>(fieldName: 'baseClass');
    if (lookup == null) return null;
    return ClassType.fromMap(lookup);
  }
  static bool _isVirtualFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool>(fieldName: 'isVirtual');
  static bool _isExtendableFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool>(fieldName: 'isExtendable');
  static List<Method> _methodsFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List?>(fieldName: 'methods');
    if (lookup == null) return [];
    return lookup.joMapNotNull((e) => Method.fromMap(e as Map)).toList();
  }
}

class Enum extends ObjectBase {
  Enum({
    required String name,
    required Token nameToken,
    required List<Annotation> annotations,
    List<String>? documentationComments,
    List<Field>? fields,
    List<EnumValue>? values,
  })  : values = values ?? [],
       super(
         name: name,
         nameToken: nameToken,
         annotations: annotations,
         documentationComments: documentationComments,
         fields: fields,
       );

  factory Enum.fromString(String s) => Enum.fromMap(fromJoText(s));

  factory Enum.fromBytes(Uint8List bytes) => Enum.fromJoFieldMap0(parseJoBinary(bytes));

  Enum.fromJoFieldMap0(Map<int, JoFieldData> map0) : this.fromJoFieldMap1(map0, map0.embeddedObject(0) ?? const {});
  Enum.fromJoFieldMap1(Map<int, JoFieldData> map0, Map<int, JoFieldData> map)
    : values = _valuesFromJoFieldMap(map),
      super.fromJoFieldMap0(map0);

  Enum.fromMap(Map<Object?, Object?> map)
    : values = _valuesFromMap(map),
      super.fromMap(map);

  List<EnumValue> values;

  Uint8List toBytes([bool $includeType=false]) =>
    encodeBytes(null, $includeType).toBytes();

  JoBinaryEncoder encodeBytes([
    JoBinaryEncoder? $derivedEncoder,
    bool $includeType=false,
  ]) {
    final encoder = JoBinaryEncoder();
    encoder.writeIterable<EnumValue>(1, values, (enc, e) => enc.writeObject(e.encodeBytes()));
    return super.encodeBytes(encoder, $includeType);
  }

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $values = values;

    final $$result = super.toMap();
    $$result['values'] = $values.map((e) => e.toMap()).toList();
    return $$result;
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static List<EnumValue> _valuesFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.listValue(1, (fieldData) => EnumValue.fromJoFieldMap0(fieldData.embeddedObject), false)!;

  static List<EnumValue> _valuesFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List?>(fieldName: 'values');
    if (lookup == null) return [];
    return lookup.joMapNotNull((e) => EnumValue.fromMap(e as Map)).toList();
  }
}

class Union extends ObjectBase {
  Union({
    required String name,
    required Token nameToken,
    required List<Annotation> annotations,
    List<String>? documentationComments,
    List<Field>? fields,
    required this.isInline,
  })  : super(
         name: name,
         nameToken: nameToken,
         annotations: annotations,
         documentationComments: documentationComments,
         fields: fields,
       );

  factory Union.fromString(String s) => Union.fromMap(fromJoText(s));

  factory Union.fromBytes(Uint8List bytes) => Union.fromJoFieldMap0(parseJoBinary(bytes));

  Union.fromJoFieldMap0(Map<int, JoFieldData> map0) : this.fromJoFieldMap1(map0, map0.embeddedObject(0) ?? const {});
  Union.fromJoFieldMap1(Map<int, JoFieldData> map0, Map<int, JoFieldData> map)
    : isInline = _isInlineFromJoFieldMap(map),
      super.fromJoFieldMap0(map0);

  Union.fromMap(Map<Object?, Object?> map)
    : isInline = _isInlineFromMap(map),
      super.fromMap(map);


  /// Whether the union is inline (type-based union) or not (key based union).
  bool isInline;

  Uint8List toBytes([bool $includeType=false]) =>
    encodeBytes(null, $includeType).toBytes();

  JoBinaryEncoder encodeBytes([
    JoBinaryEncoder? $derivedEncoder,
    bool $includeType=false,
  ]) {
    final encoder = JoBinaryEncoder();
    encoder.writeBool(1, isInline);
    return super.encodeBytes(encoder, $includeType);
  }

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $isInline = isInline;

    final $$result = super.toMap();
    $$result['isInline'] = $isInline;
    return $$result;
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static bool _isInlineFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.boolValue(1)!;

  static bool _isInlineFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool>(fieldName: 'isInline');
}

class Field {
  Field({
    this.fieldId,
    required this.name,
    required this.annotations,
    required this.type,
    this.defaultValue,
    List<String>? documentationComments,
  })  : _documentationComments = documentationComments;

  factory Field.fromString(String s) => Field.fromMap(fromJoText(s));

  factory Field.fromBytes(Uint8List bytes) => Field.fromJoFieldMap0(parseJoBinary(bytes));

  Field.fromJoFieldMap0(Map<int, JoFieldData> map)
    : fieldId = _fieldIdFromJoFieldMap(map),
      name = _nameFromJoFieldMap(map),
      annotations = _annotationsFromJoFieldMap(map),
      type = _typeFromJoFieldMap(map),
      defaultValue = _defaultValueFromJoFieldMap(map),
      _documentationComments = _documentationCommentsFromJoFieldMap(map);

  Field.fromMap(Map<Object?, Object?> map)
    : fieldId = _fieldIdFromMap(map),
      name = _nameFromMap(map),
      annotations = _annotationsFromMap(map),
      type = _typeFromMap(map),
      defaultValue = _defaultValueFromMap(map),
      _documentationComments = _documentationCommentsFromMap(map);

  int? fieldId;
  String name;
  List<Annotation> annotations;
  DataType type;
  Value? defaultValue;
  List<String> get documentationComments => _documentationComments ?? const [];
  List<String>? _documentationComments;
  set documentationComments(List<String>? $value) => _documentationComments = $value;

  Uint8List toBytes() => encodeBytes().toBytes();

  JoBinaryEncoder encodeBytes([JoBinaryEncoder? $derivedEncoder]) {
    final encoder = JoBinaryEncoder();
    final $fieldId = fieldId;
    if ($fieldId != null) {
      encoder.writeInt(0, $fieldId);
    }
    encoder.writeString(1, name);
    encoder.writeIterable<Annotation>(2, annotations, (enc, e) => enc.writeObject(e.encodeBytes()));
    final $typeEncoder = JoBinaryEncoder();
    type.encodeBytes($typeEncoder);
    encoder.writeObject(3, $typeEncoder);
    final $defaultValue = defaultValue;
    if ($defaultValue != null) {
      final $defaultValueEncoder = JoBinaryEncoder();
      $defaultValue.encodeBytes($defaultValueEncoder);
      encoder.writeObject(4, $defaultValueEncoder);
    }
    final $documentationComments = _documentationComments;
    if ($documentationComments != null) {
      encoder.writeIterable<String>(5, $documentationComments, (enc, e) => enc.writeString(e));
    }
    return encoder;
  }

  Map<String, Object?> toMap() {
    final $fieldId = fieldId;
    final $name = name;
    final $annotations = annotations;
    final $type = type;
    final $defaultValue = defaultValue;
    final $documentationComments = _documentationComments;

    return {
      if ($fieldId != null)
        'fieldId': $fieldId,
      'name': $name,
      'annotations': $annotations.map((e) => e.toMap()).toList(),
      'type': $type.toMap(),
      if ($defaultValue != null)
        'defaultValue': $defaultValue.toMap(),
      if ($documentationComments != null)
        'documentationComments': $documentationComments,
    };
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static int? _fieldIdFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.intValue(0);
  static String _nameFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.stringValue(1)!;
  static List<Annotation> _annotationsFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.listValue(2, (fieldData) => Annotation.fromJoFieldMap0(fieldData.embeddedObject), false)!;
  static DataType _typeFromJoFieldMap(Map<int, JoFieldData> map) {
    final $type = map.bytesValue(3);
    return DataType.fromBytes($type!);
  }
  static Value? _defaultValueFromJoFieldMap(Map<int, JoFieldData> map) {
    final $defaultValue = map.bytesValue(4);
    if ($defaultValue == null) return null;
    return Value.fromBytes($defaultValue);
  }
  static List<String>? _documentationCommentsFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.listValue(5, (fieldData) => fieldData.stringValue, false);

  static int? _fieldIdFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<int?>(fieldName: 'fieldId');
  static String _nameFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String>(fieldName: 'name');
  static List<Annotation> _annotationsFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List>(fieldName: 'annotations');
    return lookup.joMapNotNull((e) => Annotation.fromMap(e as Map)).toList();
  }
  static DataType _typeFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<Map>(fieldName: 'type');
    return DataType.fromMapOrNull(lookup)!;
  }
  static Value? _defaultValueFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<Map?>(fieldName: 'defaultValue');
    if (lookup == null) return null;
    return Value.fromMapOrNull(lookup);
  }
  static List<String>? _documentationCommentsFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List?>(fieldName: 'documentationComments');
    if (lookup == null) return null;
    return lookup.joMapNotNull((e) => e as String).toList();
  }
}

class EnumValue {
  EnumValue({
    required this.id,
    required this.name,
    required this.annotations,
    List<String>? documentationComments,
    required this.fieldValues,
  })  : _documentationComments = documentationComments;

  factory EnumValue.fromString(String s) => EnumValue.fromMap(fromJoText(s));

  factory EnumValue.fromBytes(Uint8List bytes) => EnumValue.fromJoFieldMap0(parseJoBinary(bytes));

  EnumValue.fromJoFieldMap0(Map<int, JoFieldData> map)
    : id = _idFromJoFieldMap(map),
      name = _nameFromJoFieldMap(map),
      annotations = _annotationsFromJoFieldMap(map),
      _documentationComments = _documentationCommentsFromJoFieldMap(map),
      fieldValues = _fieldValuesFromJoFieldMap(map);

  EnumValue.fromMap(Map<Object?, Object?> map)
    : id = _idFromMap(map),
      name = _nameFromMap(map),
      annotations = _annotationsFromMap(map),
      _documentationComments = _documentationCommentsFromMap(map),
      fieldValues = _fieldValuesFromMap(map);

  int id;
  String name;
  List<Annotation> annotations;
  List<String> get documentationComments => _documentationComments ?? const [];
  List<String>? _documentationComments;
  set documentationComments(List<String>? $value) => _documentationComments = $value;
  EnumFieldValues fieldValues;

  Uint8List toBytes() => encodeBytes().toBytes();

  JoBinaryEncoder encodeBytes([JoBinaryEncoder? $derivedEncoder]) {
    final encoder = JoBinaryEncoder();
    encoder.writeInt(0, id);
    encoder.writeString(1, name);
    encoder.writeIterable<Annotation>(2, annotations, (enc, e) => enc.writeObject(e.encodeBytes()));
    final $documentationComments = _documentationComments;
    if ($documentationComments != null) {
      encoder.writeIterable<String>(3, $documentationComments, (enc, e) => enc.writeString(e));
    }
    final $fieldValuesEncoder = JoBinaryEncoder();
    fieldValues.encodeBytes($fieldValuesEncoder);
    encoder.writeObject(4, $fieldValuesEncoder);
    return encoder;
  }

  Map<String, Object?> toMap() {
    final $id = id;
    final $name = name;
    final $annotations = annotations;
    final $documentationComments = _documentationComments;
    final $fieldValues = fieldValues;

    return {
      'id': $id,
      'name': $name,
      'annotations': $annotations.map((e) => e.toMap()).toList(),
      if ($documentationComments != null)
        'documentationComments': $documentationComments,
      'fieldValues': $fieldValues.toMap(),
    };
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static int _idFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.intValue(0)!;
  static String _nameFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.stringValue(1)!;
  static List<Annotation> _annotationsFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.listValue(2, (fieldData) => Annotation.fromJoFieldMap0(fieldData.embeddedObject), false)!;
  static List<String>? _documentationCommentsFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.listValue(3, (fieldData) => fieldData.stringValue, false);
  static EnumFieldValues _fieldValuesFromJoFieldMap(Map<int, JoFieldData> map) {
    final $fieldValues = map.bytesValue(4);
    return EnumFieldValues.fromBytes($fieldValues!);
  }

  static int _idFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<int>(fieldName: 'id');
  static String _nameFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String>(fieldName: 'name');
  static List<Annotation> _annotationsFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List>(fieldName: 'annotations');
    return lookup.joMapNotNull((e) => Annotation.fromMap(e as Map)).toList();
  }
  static List<String>? _documentationCommentsFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List?>(fieldName: 'documentationComments');
    if (lookup == null) return null;
    return lookup.joMapNotNull((e) => e as String).toList();
  }
  static EnumFieldValues _fieldValuesFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<Map>(fieldName: 'fieldValues');
    return EnumFieldValues.fromMapOrNull(lookup)!;
  }
}

class Method {
  Method({
    required this.name,
    required this.annotations,
    required this.returnType,
    required this.parameters,
  });

  factory Method.fromString(String s) => Method.fromMap(fromJoText(s));

  factory Method.fromBytes(Uint8List bytes) => Method.fromJoFieldMap0(parseJoBinary(bytes));

  Method.fromJoFieldMap0(Map<int, JoFieldData> map)
    : name = _nameFromJoFieldMap(map),
      annotations = _annotationsFromJoFieldMap(map),
      returnType = _returnTypeFromJoFieldMap(map),
      parameters = _parametersFromJoFieldMap(map);

  Method.fromMap(Map<Object?, Object?> map)
    : name = _nameFromMap(map),
      annotations = _annotationsFromMap(map),
      returnType = _returnTypeFromMap(map),
      parameters = _parametersFromMap(map);

  String name;
  List<Annotation> annotations;
  DataType returnType;
  List<MethodParameter> parameters;

  Uint8List toBytes() => encodeBytes().toBytes();

  JoBinaryEncoder encodeBytes([JoBinaryEncoder? $derivedEncoder]) {
    final encoder = JoBinaryEncoder();
    encoder.writeString(0, name);
    encoder.writeIterable<Annotation>(1, annotations, (enc, e) => enc.writeObject(e.encodeBytes()));
    final $returnTypeEncoder = JoBinaryEncoder();
    returnType.encodeBytes($returnTypeEncoder);
    encoder.writeObject(2, $returnTypeEncoder);
    encoder.writeIterable<MethodParameter>(3, parameters, (enc, e) => enc.writeObject(e.encodeBytes()));
    return encoder;
  }

  Map<String, Object?> toMap() {
    final $name = name;
    final $annotations = annotations;
    final $returnType = returnType;
    final $parameters = parameters;

    return {
      'name': $name,
      'annotations': $annotations.map((e) => e.toMap()).toList(),
      'returnType': $returnType.toMap(),
      'parameters': $parameters.map((e) => e.toMap()).toList(),
    };
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static String _nameFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.stringValue(0)!;
  static List<Annotation> _annotationsFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.listValue(1, (fieldData) => Annotation.fromJoFieldMap0(fieldData.embeddedObject), false)!;
  static DataType _returnTypeFromJoFieldMap(Map<int, JoFieldData> map) {
    final $returnType = map.bytesValue(2);
    return DataType.fromBytes($returnType!);
  }
  static List<MethodParameter> _parametersFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.listValue(3, (fieldData) => MethodParameter.fromJoFieldMap0(fieldData.embeddedObject), false)!;

  static String _nameFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String>(fieldName: 'name');
  static List<Annotation> _annotationsFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List>(fieldName: 'annotations');
    return lookup.joMapNotNull((e) => Annotation.fromMap(e as Map)).toList();
  }
  static DataType _returnTypeFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<Map>(fieldName: 'returnType');
    return DataType.fromMapOrNull(lookup)!;
  }
  static List<MethodParameter> _parametersFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List>(fieldName: 'parameters');
    return lookup.joMapNotNull((e) => MethodParameter.fromMap(e as Map)).toList();
  }
}

class MethodParameter {
  MethodParameter({
    required this.name,
    required this.annotations,
    required this.type,
  });

  factory MethodParameter.fromString(String s) => MethodParameter.fromMap(fromJoText(s));

  factory MethodParameter.fromBytes(Uint8List bytes) => MethodParameter.fromJoFieldMap0(parseJoBinary(bytes));

  MethodParameter.fromJoFieldMap0(Map<int, JoFieldData> map)
    : name = _nameFromJoFieldMap(map),
      annotations = _annotationsFromJoFieldMap(map),
      type = _typeFromJoFieldMap(map);

  MethodParameter.fromMap(Map<Object?, Object?> map)
    : name = _nameFromMap(map),
      annotations = _annotationsFromMap(map),
      type = _typeFromMap(map);

  String name;
  List<Annotation> annotations;
  DataType type;

  Uint8List toBytes() => encodeBytes().toBytes();

  JoBinaryEncoder encodeBytes([JoBinaryEncoder? $derivedEncoder]) {
    final encoder = JoBinaryEncoder();
    encoder.writeString(0, name);
    encoder.writeIterable<Annotation>(1, annotations, (enc, e) => enc.writeObject(e.encodeBytes()));
    final $typeEncoder = JoBinaryEncoder();
    type.encodeBytes($typeEncoder);
    encoder.writeObject(2, $typeEncoder);
    return encoder;
  }

  Map<String, Object?> toMap() {
    final $name = name;
    final $annotations = annotations;
    final $type = type;

    return {
      'name': $name,
      'annotations': $annotations.map((e) => e.toMap()).toList(),
      'type': $type.toMap(),
    };
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static String _nameFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.stringValue(0)!;
  static List<Annotation> _annotationsFromJoFieldMap(Map<int, JoFieldData> map) =>
    map.listValue(1, (fieldData) => Annotation.fromJoFieldMap0(fieldData.embeddedObject), false)!;
  static DataType _typeFromJoFieldMap(Map<int, JoFieldData> map) {
    final $type = map.bytesValue(2);
    return DataType.fromBytes($type!);
  }

  static String _nameFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String>(fieldName: 'name');
  static List<Annotation> _annotationsFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List>(fieldName: 'annotations');
    return lookup.joMapNotNull((e) => Annotation.fromMap(e as Map)).toList();
  }
  static DataType _typeFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<Map>(fieldName: 'type');
    return DataType.fromMapOrNull(lookup)!;
  }
}

enum EnumFieldValues_ActiveElement {
  none,
  list,
  map,
}

@immutable
class EnumFieldValues {
  const EnumFieldValues.none()
    : activeElement = EnumFieldValues_ActiveElement.none,
      _value = const Void();

  const EnumFieldValues.list(List<Value> list)
    : activeElement = EnumFieldValues_ActiveElement.list,
      _value = list;

  const EnumFieldValues.map(Map<String, Value> map)
    : activeElement = EnumFieldValues_ActiveElement.map,
      _value = map;

  static EnumFieldValues? fromMapOrNull(Map<Object?, Object?> map) {
    final entries = map.entries;
    if (entries.length != 1) return null;
    final entry = entries.first;
    switch (entry.key) {
      case 'none':
        return _noneFromValue(entry.value);
      case 'list':
        return _listFromValue(entry.value);
      case 'map':
        return _mapFromValue(entry.value);
      default:
        return null;
    }
  }

  factory EnumFieldValues.fromBytes(Uint8List bytes) =>
    EnumFieldValues.fromJoFieldMapOrNull(parseJoBinary(bytes))!;

  static EnumFieldValues? fromJoFieldMapOrNull(Map<int, JoFieldData> map) {
    final entries = map.entries;
    if (entries.length != 1) return null;
    final entry = entries.first;
    switch (entry.key) {
      case 0:
        return _noneFromJoField();
      case 1:
        return _listFromJoField(entry.value);
      case 2:
        return _mapFromJoField(entry.value);
      default:
        return null;
    }
  }

  T when<T>({
    required T Function() none,
    required T Function(List<Value>) list,
    required T Function(Map<String, Value>) map,
  }) {
    switch (activeElement) {
      case EnumFieldValues_ActiveElement.none:
        return none();
      case EnumFieldValues_ActiveElement.list:
        return list(_value as List<Value>);
      case EnumFieldValues_ActiveElement.map:
        return map(_value as Map<String, Value>);
    }
  }

  final EnumFieldValues_ActiveElement activeElement;
  final Object _value;

  Void get none => noneOrNull!;
  Void? get noneOrNull =>
    activeElement == EnumFieldValues_ActiveElement.none
      ? _value as Void
      : null;

  List<Value> get list => listOrNull!;
  List<Value>? get listOrNull =>
    activeElement == EnumFieldValues_ActiveElement.list
      ? _value as List<Value>
      : null;

  Map<String, Value> get map => mapOrNull!;
  Map<String, Value>? get mapOrNull =>
    activeElement == EnumFieldValues_ActiveElement.map
      ? _value as Map<String, Value>
      : null;

  Uint8List toBytes() {
    final encoder = JoBinaryEncoder();
    encodeBytes(encoder);
    return encoder.toBytes();
  }

  void encodeBytes(JoBinaryEncoder encoder) {
    switch (activeElement) {
     case EnumFieldValues_ActiveElement.none:
       encoder.writeObject(0, none.encodeBytes());
       break;
     case EnumFieldValues_ActiveElement.list:
       encoder.writeIterable<Value>(1, list, (enc, e) {
        final objectEncoder = JoBinaryEncoder();
        e.encodeBytes(objectEncoder);
        enc.writeObject(objectEncoder);
      });
       break;
     case EnumFieldValues_ActiveElement.map:
       encoder.writeMap<String, Value>(2, map, (enc, e) => enc.writeString(e), (enc, e) {
        final objectEncoder = JoBinaryEncoder();
        e.encodeBytes(objectEncoder);
        enc.writeObject(objectEncoder);
      });
       break;
    }
  }

  Map<String, Object?> toMap() {
    switch (activeElement) {
      case EnumFieldValues_ActiveElement.none:
        final $none = _value as Void;
        return { 'none': $none.toMap() };
      case EnumFieldValues_ActiveElement.list:
        final $list = _value as List<Value>;
        return { 'list': $list.map((e) => e.toMap()).toList() };
      case EnumFieldValues_ActiveElement.map:
        final $map = _value as Map<String, Value>;
        return { 'map': $map.map((k, v) => MapEntry(k, v.toMap())) };
    }
  }
  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static EnumFieldValues _noneFromValue(Object? value) =>
    const EnumFieldValues.none();
  static EnumFieldValues _listFromValue(Object? value) =>
    EnumFieldValues.list((value as Iterable).joMapNotNull((e) => Value.fromMapOrNull(e as Map)).toList());
  static EnumFieldValues _mapFromValue(Object? value) =>
    EnumFieldValues.map((value as Map).joMapNotNull((k) => k as String, (v) => Value.fromMapOrNull(v as Map)));

  static EnumFieldValues _noneFromJoField() =>
    const EnumFieldValues.none();
  static EnumFieldValues _listFromJoField(JoFieldData data) =>
    EnumFieldValues.list(data.listValue((fieldData) => Value.fromJoFieldMapOrNull(fieldData.embeddedObject), true));
  static EnumFieldValues _mapFromJoField(JoFieldData data) =>
    EnumFieldValues.map(data.mapValue((fieldData) => fieldData.stringValue, (fieldData) => Value.fromJoFieldMapOrNull(fieldData.embeddedObject), true));
}

void joRegister() {}
