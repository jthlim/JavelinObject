// ** WARNING **
// This file is autogenerated by Javelin Object Compiler (joc).
// Do not edit it directly.
//
// ignore_for_file: annotate_overrides
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: directives_ordering
// ignore_for_file: prefer_const_constructors_in_immutables
// ignore_for_file: sort_constructors_first
// ignore_for_file: unused_import
import 'package:javelin_object/jo_internal.dart';

import '../value.jo.dart';

@immutable
class ParsedAnnotation {
  const ParsedAnnotation({
    BoolOrCondition? enabled,
  })  : _enabled = enabled;

  ParsedAnnotation.fromMap(Map<Object?, Object?> map)
    : _enabled = _enabledFromMap(map);

  BoolOrCondition get enabled => _enabled ?? const BoolOrCondition.enabled(true);
  final BoolOrCondition? _enabled;

  String get $joType => 'ParsedAnnotation';

  Map<String, Object?> toMap([bool $includeType=true]) {
    final $enabled = _enabled;

    return {
      if ($includeType) '\$t': $joType,
      if ($enabled != null)
        'enabled': $enabled.toObject(),
    };
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static BoolOrCondition? _enabledFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<Object?>(fieldName: 'enabled');
    if (lookup == null) return null;
    return BoolOrCondition.fromObjectOrNull(lookup);
  }
}

class UnknownAnnotation extends ParsedAnnotation {
  const UnknownAnnotation({
    BoolOrCondition? enabled,
    required this.name,
    required this.parameters,
  })  : super(
         enabled: enabled,
       );

  final String name;
  final Map<String, Value> parameters;

  String get $joType => 'UnknownAnnotation';

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $name = name;
    final $parameters = parameters;

    final $$result = super.toMap();
    $$result['name'] = $name;
    $$result['parameters'] = $parameters.map((k, v) => MapEntry(k, v.toMap()));
    return $$result;
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

@immutable
class Condition {
  const Condition({
    this.includedRoles = const [],
    this.excludedRoles = const [],
  });

  Condition.fromMap(Map<Object?, Object?> map)
    : includedRoles = _includedRolesFromMap(map),
      excludedRoles = _excludedRolesFromMap(map)  {
    map.validateKeys(validKeys: const {
      'includedRoles',
      'excludedRoles',
    });
  }

  final List<String> includedRoles;
  final List<String> excludedRoles;

  Map<String, Object?> toMap() {
    final $includedRoles = includedRoles;
    final $excludedRoles = excludedRoles;

    return {
      'includedRoles': $includedRoles,
      'excludedRoles': $excludedRoles,
    };
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static List<String> _includedRolesFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List?>(fieldName: 'includedRoles');
    if (lookup == null) return const [];
    return lookup.joMapNotNull((e) => e as String).toList();
  }
  static List<String> _excludedRolesFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List?>(fieldName: 'excludedRoles');
    if (lookup == null) return const [];
    return lookup.joMapNotNull((e) => e as String).toList();
  }
}

/// Controls whether a class can be directly instantiated or not.
@immutable
class Abstract extends ParsedAnnotation {
  const Abstract({
    BoolOrCondition? enabled,
  })  : super(
         enabled: enabled,
       );

  Abstract.fromMap(Map<Object?, Object?> map)
    : super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'enabled',
    });
  }

  String get $joType => 'Abstract';


  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

/// Annotation used for Unions to control what class name and field are 
/// generated to represent the active type.
@immutable
class ActiveElement extends ParsedAnnotation {
  const ActiveElement({
    BoolOrCondition? enabled,
    this.className,
    this.fieldName,
  })  : super(
         enabled: enabled,
       );

  ActiveElement.fromMap(Map<Object?, Object?> map)
    : className = _classNameFromMap(map),
      fieldName = _fieldNameFromMap(map),
      super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'className',
      'fieldName',
      'enabled',
    });
  }

  final String? className;
  final String? fieldName;

  String get $joType => 'ActiveElement';

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $className = className;
    final $fieldName = fieldName;

    final $$result = super.toMap();
    if ($className != null) $$result['className'] = $className;
    if ($fieldName != null) $$result['fieldName'] = $fieldName;
    return $$result;
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static String? _classNameFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String?>(fieldName: 'className');
  static String? _fieldNameFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String?>(fieldName: 'fieldName');
}

@immutable
class Alias extends ParsedAnnotation {
  const Alias({
    BoolOrCondition? enabled,
    required this.alias,
  })  : super(
         enabled: enabled,
       );

  Alias.fromMap(Map<Object?, Object?> map)
    : alias = _aliasFromMap(map),
      super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'alias',
      'enabled',
    });
  }

  final String alias;

  String get $joType => 'Alias';

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $alias = alias;

    final $$result = super.toMap();
    $$result['alias'] = $alias;
    return $$result;
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static String _aliasFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String>(fieldName: 'alias');
}

/// Controls whether an element is present or not.
///
/// @Available can be used on classes, enums, unions, fields and enum values.
@immutable
class Available extends ParsedAnnotation {
  const Available({
    BoolOrCondition? enabled,
    BoolOrCondition? available,
  })  : _available = available,
       super(
         enabled: enabled,
       );

  Available.fromMap(Map<Object?, Object?> map)
    : _available = _availableFromMap(map),
      super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'available',
      'enabled',
    });
  }

  BoolOrCondition get available => _available ?? const BoolOrCondition.enabled(true);
  final BoolOrCondition? _available;

  String get $joType => 'Available';

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $available = _available;

    final $$result = super.toMap();
    if ($available != null) $$result['available'] = $available.toObject();
    return $$result;
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static BoolOrCondition? _availableFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<Object?>(fieldName: 'available');
    if (lookup == null) return null;
    return BoolOrCondition.fromObjectOrNull(lookup);
  }
}

/// Adds Builder capabilities to a class.
///
/// Adds ClassName.builder() method which returns _ClassNameBuilder class.
@immutable
class Buildable extends ParsedAnnotation {
  const Buildable({
    BoolOrCondition? enabled,
    bool? includeFactory,
    bool? includeToBuilder,
  })  : _includeFactory = includeFactory,
       _includeToBuilder = includeToBuilder,
       super(
         enabled: enabled,
       );

  Buildable.fromMap(Map<Object?, Object?> map)
    : _includeFactory = _includeFactoryFromMap(map),
      _includeToBuilder = _includeToBuilderFromMap(map),
      super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'includeFactory',
      'includeToBuilder',
      'enabled',
    });
  }

  bool get includeFactory => _includeFactory ?? true;
  final bool? _includeFactory;
  bool get includeToBuilder => _includeToBuilder ?? true;
  final bool? _includeToBuilder;

  String get $joType => 'Buildable';

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $includeFactory = _includeFactory;
    final $includeToBuilder = _includeToBuilder;

    final $$result = super.toMap();
    if ($includeFactory != null) $$result['includeFactory'] = $includeFactory;
    if ($includeToBuilder != null) $$result['includeToBuilder'] = $includeToBuilder;
    return $$result;
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static bool? _includeFactoryFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeFactory');
  static bool? _includeToBuilderFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeToBuilder');
}

@immutable
class Column extends ParsedAnnotation {
  const Column({
    BoolOrCondition? enabled,
    this.name,
    bool? primaryKey,
    bool? sequence,
    bool? unique,
  })  : _primaryKey = primaryKey,
       _sequence = sequence,
       _unique = unique,
       super(
         enabled: enabled,
       );

  Column.fromMap(Map<Object?, Object?> map)
    : name = _nameFromMap(map),
      _primaryKey = _primaryKeyFromMap(map),
      _sequence = _sequenceFromMap(map),
      _unique = _uniqueFromMap(map),
      super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'name',
      'primaryKey',
      'sequence',
      'unique',
      'enabled',
    });
  }

  final String? name;
  bool get primaryKey => _primaryKey ?? false;
  final bool? _primaryKey;
  bool get sequence => _sequence ?? false;
  final bool? _sequence;
  bool get unique => _unique ?? false;
  final bool? _unique;

  String get $joType => 'Column';

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $name = name;
    final $primaryKey = _primaryKey;
    final $sequence = _sequence;
    final $unique = _unique;

    final $$result = super.toMap();
    if ($name != null) $$result['name'] = $name;
    if ($primaryKey != null) $$result['primaryKey'] = $primaryKey;
    if ($sequence != null) $$result['sequence'] = $sequence;
    if ($unique != null) $$result['unique'] = $unique;
    return $$result;
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static String? _nameFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String?>(fieldName: 'name');
  static bool? _primaryKeyFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'primaryKey');
  static bool? _sequenceFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'sequence');
  static bool? _uniqueFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'unique');
}

/// Adds hashCode and operator==.
///
/// If orderedOperators is `true`, then compareTo and ordered operators are
/// created too.
@immutable
class ComparableClass extends ParsedAnnotation {
  const ComparableClass({
    BoolOrCondition? enabled,
    this.fields,
    bool? orderedOperators,
  })  : _orderedOperators = orderedOperators,
       super(
         enabled: enabled,
       );

  ComparableClass.fromMap(Map<Object?, Object?> map)
    : fields = _fieldsFromMap(map),
      _orderedOperators = _orderedOperatorsFromMap(map),
      super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'fields',
      'orderedOperators',
      'enabled',
    });
  }

  final List<String>? fields;
  bool get orderedOperators => _orderedOperators ?? false;
  final bool? _orderedOperators;

  String get $joType => 'ComparableClass';

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $fields = fields;
    final $orderedOperators = _orderedOperators;

    final $$result = super.toMap();
    if ($fields != null) $$result['fields'] = $fields;
    if ($orderedOperators != null) $$result['orderedOperators'] = $orderedOperators;
    return $$result;
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static List<String>? _fieldsFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List?>(fieldName: 'fields');
    if (lookup == null) return null;
    return lookup.joMapNotNull((e) => e as String).toList();
  }
  static bool? _orderedOperatorsFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'orderedOperators');
}

/// Adds hashCode and operator==.
///
/// If orderedOperators is `true`, then compareTo and ordered operators are
/// created too.
@immutable
class ComparableUnion extends ParsedAnnotation {
  const ComparableUnion({
    BoolOrCondition? enabled,
  })  : super(
         enabled: enabled,
       );

  ComparableUnion.fromMap(Map<Object?, Object?> map)
    : super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'enabled',
    });
  }

  String get $joType => 'ComparableUnion';


  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

@immutable
class ConvertClass extends ParsedAnnotation {
  const ConvertClass({
    BoolOrCondition? enabled,
    bool? includeFromMap,
    bool? validateFromMap,
    bool? includeToMap,
    bool? includeFromJson,
    bool? validateFromJson,
    bool? includeToJson,
    this.jsonTypeName,
    this.jsonTypeKey,
    this.typeName,
    this.typeKey,
    bool? includeFromYaml,
    bool? includeFromBinary,
    bool? includeToBinary,
    this.derivedFieldId,
    this.typeId,
    this.typeIdFieldId,
    bool? includeFromString,
    bool? includeToString,
    bool? includeToDartString,
  })  : _includeFromMap = includeFromMap,
       _validateFromMap = validateFromMap,
       _includeToMap = includeToMap,
       _includeFromJson = includeFromJson,
       _validateFromJson = validateFromJson,
       _includeToJson = includeToJson,
       _includeFromYaml = includeFromYaml,
       _includeFromBinary = includeFromBinary,
       _includeToBinary = includeToBinary,
       _includeFromString = includeFromString,
       _includeToString = includeToString,
       _includeToDartString = includeToDartString,
       super(
         enabled: enabled,
       );

  ConvertClass.fromMap(Map<Object?, Object?> map)
    : _includeFromMap = _includeFromMapFromMap(map),
      _validateFromMap = _validateFromMapFromMap(map),
      _includeToMap = _includeToMapFromMap(map),
      _includeFromJson = _includeFromJsonFromMap(map),
      _validateFromJson = _validateFromJsonFromMap(map),
      _includeToJson = _includeToJsonFromMap(map),
      jsonTypeName = _jsonTypeNameFromMap(map),
      jsonTypeKey = _jsonTypeKeyFromMap(map),
      typeName = _typeNameFromMap(map),
      typeKey = _typeKeyFromMap(map),
      _includeFromYaml = _includeFromYamlFromMap(map),
      _includeFromBinary = _includeFromBinaryFromMap(map),
      _includeToBinary = _includeToBinaryFromMap(map),
      derivedFieldId = _derivedFieldIdFromMap(map),
      typeId = _typeIdFromMap(map),
      typeIdFieldId = _typeIdFieldIdFromMap(map),
      _includeFromString = _includeFromStringFromMap(map),
      _includeToString = _includeToStringFromMap(map),
      _includeToDartString = _includeToDartStringFromMap(map),
      super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'includeFromMap',
      'fromMap',
      'validateFromMap',
      'includeToMap',
      'toMap',
      'includeFromJson',
      'fromJson',
      'validateFromJson',
      'includeToJson',
      'toJson',
      'jsonTypeName',
      'jsonTypeKey',
      'typeName',
      'typeKey',
      'includeFromYaml',
      'fromYaml',
      'includeFromBinary',
      'fromBinary',
      'fromBytes',
      'includeToBinary',
      'toBinary',
      'toBytes',
      'derivedFieldId',
      'typeId',
      'typeIdFieldId',
      'includeFromString',
      'fromString',
      'fromText',
      'includeToString',
      'toString',
      'toText',
      'includeToDartString',
      'toDartString',
      'enabled',
    });
  }


  /// Adds `static Type fromMap(Map map)` factory to the class.
  bool get includeFromMap => _includeFromMap ?? false;
  final bool? _includeFromMap;

  /// Causes field names to be validated in fromMap() method.
  bool get validateFromMap => _validateFromMap ?? false;
  final bool? _validateFromMap;

  /// Adds `Map<String, Objec?> toMap()` method to the class.
  bool get includeToMap => _includeToMap ?? false;
  final bool? _includeToMap;

  /// Adds `static Type fromJson(String json)` factory to the class.
  bool get includeFromJson => _includeFromJson ?? false;
  final bool? _includeFromJson;

  /// Causes field names to be validated in fromJsonMap() method that is used
  /// by fromJson().
  bool get validateFromJson => _validateFromJson ?? false;
  final bool? _validateFromJson;

  /// Adds `String toJson({bool pretty = false})` method to the class.
  bool get includeToJson => _includeToJson ?? false;
  final bool? _includeToJson;

  /// The name used to identify the type when serializing json.
  ///
  /// Will fallback to typeName, or the class name.
  final String? jsonTypeName;

  /// The key used to store the typeName in a JSON map.
  ///
  /// Defaults to '$t'.
  final String? jsonTypeKey;

  /// The name used to identify the type when serializing.
  ///
  /// Defaults to the class name.
  final String? typeName;

  /// The key used to store the typeName in a map.
  ///
  /// Defaults to '$t'.
  final String? typeKey;

  /// Adds `static Type fromYaml(String yaml)` factory to the class.
  ///
  /// This will implicitly enable [includeFromMap].
  bool get includeFromYaml => _includeFromYaml ?? false;
  final bool? _includeFromYaml;

  /// Adds `factory Type.fromBytes(Uint8List bytes)` factory to the class.
  bool get includeFromBinary => _includeFromBinary ?? false;
  final bool? _includeFromBinary;

  /// Adds `Uint8List toBytes()` method to the class.
  bool get includeToBinary => _includeToBinary ?? false;
  final bool? _includeToBinary;

  /// The fieldId to use when serializing a derived class that has fields. 
  ///
  /// Defaults to 0 if not specified.
  final int? derivedFieldId;

  /// The typeId used when serializing this class.
  ///
  /// It must be specified if the class has a parent or is extendable and is 
  /// not abstract.
  final int? typeId;

  /// The fieldId to use to store the typeId.
  ///
  /// Defaults to 1 if not specified.
  final int? typeIdFieldId;

  /// Adds `static Type fromString(String string)` factory to the class.
  ///
  /// This will implicitly enable [includeFromMap].
  bool get includeFromString => _includeFromString ?? false;
  final bool? _includeFromString;

  /// Adds `String toString({bool pretty = true})` method to the class.
  ///
  /// This will implicitly enable [includeToMap].
  bool get includeToString => _includeToString ?? false;
  final bool? _includeToString;

  /// Adds 'String toDartString()` method to the class.
  bool get includeToDartString => _includeToDartString ?? false;
  final bool? _includeToDartString;

  String get $joType => 'ConvertClass';

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $includeFromMap = _includeFromMap;
    final $validateFromMap = _validateFromMap;
    final $includeToMap = _includeToMap;
    final $includeFromJson = _includeFromJson;
    final $validateFromJson = _validateFromJson;
    final $includeToJson = _includeToJson;
    final $jsonTypeName = jsonTypeName;
    final $jsonTypeKey = jsonTypeKey;
    final $typeName = typeName;
    final $typeKey = typeKey;
    final $includeFromYaml = _includeFromYaml;
    final $includeFromBinary = _includeFromBinary;
    final $includeToBinary = _includeToBinary;
    final $derivedFieldId = derivedFieldId;
    final $typeId = typeId;
    final $typeIdFieldId = typeIdFieldId;
    final $includeFromString = _includeFromString;
    final $includeToString = _includeToString;
    final $includeToDartString = _includeToDartString;

    final $$result = super.toMap();
    if ($includeFromMap != null) $$result['includeFromMap'] = $includeFromMap;
    if ($validateFromMap != null) $$result['validateFromMap'] = $validateFromMap;
    if ($includeToMap != null) $$result['includeToMap'] = $includeToMap;
    if ($includeFromJson != null) $$result['includeFromJson'] = $includeFromJson;
    if ($validateFromJson != null) $$result['validateFromJson'] = $validateFromJson;
    if ($includeToJson != null) $$result['includeToJson'] = $includeToJson;
    if ($jsonTypeName != null) $$result['jsonTypeName'] = $jsonTypeName;
    if ($jsonTypeKey != null) $$result['jsonTypeKey'] = $jsonTypeKey;
    if ($typeName != null) $$result['typeName'] = $typeName;
    if ($typeKey != null) $$result['typeKey'] = $typeKey;
    if ($includeFromYaml != null) $$result['includeFromYaml'] = $includeFromYaml;
    if ($includeFromBinary != null) $$result['includeFromBinary'] = $includeFromBinary;
    if ($includeToBinary != null) $$result['includeToBinary'] = $includeToBinary;
    if ($derivedFieldId != null) $$result['derivedFieldId'] = $derivedFieldId;
    if ($typeId != null) $$result['typeId'] = $typeId;
    if ($typeIdFieldId != null) $$result['typeIdFieldId'] = $typeIdFieldId;
    if ($includeFromString != null) $$result['includeFromString'] = $includeFromString;
    if ($includeToString != null) $$result['includeToString'] = $includeToString;
    if ($includeToDartString != null) $$result['includeToDartString'] = $includeToDartString;
    return $$result;
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static bool? _includeFromMapFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeFromMap', aliases: const ['fromMap']);
  static bool? _validateFromMapFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'validateFromMap');
  static bool? _includeToMapFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeToMap', aliases: const ['toMap']);
  static bool? _includeFromJsonFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeFromJson', aliases: const ['fromJson']);
  static bool? _validateFromJsonFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'validateFromJson');
  static bool? _includeToJsonFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeToJson', aliases: const ['toJson']);
  static String? _jsonTypeNameFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String?>(fieldName: 'jsonTypeName');
  static String? _jsonTypeKeyFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String?>(fieldName: 'jsonTypeKey');
  static String? _typeNameFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String?>(fieldName: 'typeName');
  static String? _typeKeyFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String?>(fieldName: 'typeKey');
  static bool? _includeFromYamlFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeFromYaml', aliases: const ['fromYaml']);
  static bool? _includeFromBinaryFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeFromBinary', aliases: const ['fromBinary', 'fromBytes']);
  static bool? _includeToBinaryFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeToBinary', aliases: const ['toBinary', 'toBytes']);
  static int? _derivedFieldIdFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<int?>(fieldName: 'derivedFieldId');
  static int? _typeIdFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<int?>(fieldName: 'typeId');
  static int? _typeIdFieldIdFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<int?>(fieldName: 'typeIdFieldId');
  static bool? _includeFromStringFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeFromString', aliases: const ['fromString', 'fromText']);
  static bool? _includeToStringFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeToString', aliases: const ['toString', 'toText']);
  static bool? _includeToDartStringFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeToDartString', aliases: const ['toDartString']);
}

@immutable
class ConvertEnum extends ParsedAnnotation {
  const ConvertEnum({
    BoolOrCondition? enabled,
    bool? includeFromJson,
    bool? includeToJson,
    bool? includeFromString,
    bool? includeToString,
    bool? includeFromId,
    bool? includeToDartString,
  })  : _includeFromJson = includeFromJson,
       _includeToJson = includeToJson,
       _includeFromString = includeFromString,
       _includeToString = includeToString,
       _includeFromId = includeFromId,
       _includeToDartString = includeToDartString,
       super(
         enabled: enabled,
       );

  ConvertEnum.fromMap(Map<Object?, Object?> map)
    : _includeFromJson = _includeFromJsonFromMap(map),
      _includeToJson = _includeToJsonFromMap(map),
      _includeFromString = _includeFromStringFromMap(map),
      _includeToString = _includeToStringFromMap(map),
      _includeFromId = _includeFromIdFromMap(map),
      _includeToDartString = _includeToDartStringFromMap(map),
      super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'includeFromJson',
      'fromJson',
      'includeToJson',
      'toJson',
      'includeFromString',
      'fromString',
      'fromText',
      'includeToString',
      'toString',
      'toText',
      'includeFromId',
      'fromId',
      'includeToDartString',
      'toDartString',
      'enabled',
    });
  }


  /// Adds `static Type fromJson(String json)` factory to the class.
  bool get includeFromJson => _includeFromJson ?? false;
  final bool? _includeFromJson;

  /// Adds `String toJson({bool pretty = false})` method to the class.
  bool get includeToJson => _includeToJson ?? false;
  final bool? _includeToJson;

  /// Adds `static Type fromString(String string)` factory to the class.
  ///
  /// This will implicitly enable [includeFromMap].
  bool get includeFromString => _includeFromString ?? false;
  final bool? _includeFromString;

  /// Adds `String toString({bool pretty = true})` method to the class.
  ///
  /// This will implicitly enable [includeToMap].
  bool get includeToString => _includeToString ?? false;
  final bool? _includeToString;

  /// Adds `Type fromId(int id)` for enum classes.
  bool get includeFromId => _includeFromId ?? false;
  final bool? _includeFromId;

  /// Adds 'String toDartString()` method to the class.
  bool get includeToDartString => _includeToDartString ?? false;
  final bool? _includeToDartString;

  String get $joType => 'ConvertEnum';

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $includeFromJson = _includeFromJson;
    final $includeToJson = _includeToJson;
    final $includeFromString = _includeFromString;
    final $includeToString = _includeToString;
    final $includeFromId = _includeFromId;
    final $includeToDartString = _includeToDartString;

    final $$result = super.toMap();
    if ($includeFromJson != null) $$result['includeFromJson'] = $includeFromJson;
    if ($includeToJson != null) $$result['includeToJson'] = $includeToJson;
    if ($includeFromString != null) $$result['includeFromString'] = $includeFromString;
    if ($includeToString != null) $$result['includeToString'] = $includeToString;
    if ($includeFromId != null) $$result['includeFromId'] = $includeFromId;
    if ($includeToDartString != null) $$result['includeToDartString'] = $includeToDartString;
    return $$result;
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static bool? _includeFromJsonFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeFromJson', aliases: const ['fromJson']);
  static bool? _includeToJsonFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeToJson', aliases: const ['toJson']);
  static bool? _includeFromStringFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeFromString', aliases: const ['fromString', 'fromText']);
  static bool? _includeToStringFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeToString', aliases: const ['toString', 'toText']);
  static bool? _includeFromIdFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeFromId', aliases: const ['fromId']);
  static bool? _includeToDartStringFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeToDartString', aliases: const ['toDartString']);
}

@immutable
class ConvertUnion extends ParsedAnnotation {
  const ConvertUnion({
    BoolOrCondition? enabled,
    bool? includeFromMap,
    bool? validateFromMap,
    bool? includeToMap,
    bool? includeFromJson,
    bool? validateFromJson,
    bool? includeToJson,
    bool? includeFromYaml,
    bool? includeFromBinary,
    bool? includeToBinary,
    bool? includeFromString,
    bool? includeToString,
    bool? includeFromObject,
    bool? includeToObject,
    bool? includeToDartString,
  })  : _includeFromMap = includeFromMap,
       _validateFromMap = validateFromMap,
       _includeToMap = includeToMap,
       _includeFromJson = includeFromJson,
       _validateFromJson = validateFromJson,
       _includeToJson = includeToJson,
       _includeFromYaml = includeFromYaml,
       _includeFromBinary = includeFromBinary,
       _includeToBinary = includeToBinary,
       _includeFromString = includeFromString,
       _includeToString = includeToString,
       _includeFromObject = includeFromObject,
       _includeToObject = includeToObject,
       _includeToDartString = includeToDartString,
       super(
         enabled: enabled,
       );

  ConvertUnion.fromMap(Map<Object?, Object?> map)
    : _includeFromMap = _includeFromMapFromMap(map),
      _validateFromMap = _validateFromMapFromMap(map),
      _includeToMap = _includeToMapFromMap(map),
      _includeFromJson = _includeFromJsonFromMap(map),
      _validateFromJson = _validateFromJsonFromMap(map),
      _includeToJson = _includeToJsonFromMap(map),
      _includeFromYaml = _includeFromYamlFromMap(map),
      _includeFromBinary = _includeFromBinaryFromMap(map),
      _includeToBinary = _includeToBinaryFromMap(map),
      _includeFromString = _includeFromStringFromMap(map),
      _includeToString = _includeToStringFromMap(map),
      _includeFromObject = _includeFromObjectFromMap(map),
      _includeToObject = _includeToObjectFromMap(map),
      _includeToDartString = _includeToDartStringFromMap(map),
      super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'includeFromMap',
      'fromMap',
      'validateFromMap',
      'includeToMap',
      'toMap',
      'includeFromJson',
      'fromJson',
      'validateFromJson',
      'includeToJson',
      'toJson',
      'includeFromYaml',
      'fromYaml',
      'includeFromBinary',
      'fromBinary',
      'fromBytes',
      'includeToBinary',
      'toBinary',
      'toBytes',
      'includeFromString',
      'fromString',
      'fromText',
      'includeToString',
      'toString',
      'toText',
      'includeFromObject',
      'fromObject',
      'includeToObject',
      'toObject',
      'includeToDartString',
      'toDartString',
      'enabled',
    });
  }


  /// Adds `static Type fromMap(Map map)` factory to the class.
  bool get includeFromMap => _includeFromMap ?? false;
  final bool? _includeFromMap;

  /// Causes field names to be validated in fromMap() method.
  bool get validateFromMap => _validateFromMap ?? false;
  final bool? _validateFromMap;

  /// Adds `Map<String, Objec?> toMap()` method to the class.
  bool get includeToMap => _includeToMap ?? false;
  final bool? _includeToMap;

  /// Adds `static Type fromJson(String json)` factory to the class.
  bool get includeFromJson => _includeFromJson ?? false;
  final bool? _includeFromJson;

  /// Causes field names to be validated in fromJsonMap() method that is used
  /// by fromJson().
  bool get validateFromJson => _validateFromJson ?? false;
  final bool? _validateFromJson;

  /// Adds `String toJson({bool pretty = false})` method to the class.
  bool get includeToJson => _includeToJson ?? false;
  final bool? _includeToJson;

  /// Adds `static Type fromYaml(String yaml)` factory to the class.
  ///
  /// This will implicitly enable [includeFromMap].
  bool get includeFromYaml => _includeFromYaml ?? false;
  final bool? _includeFromYaml;

  /// Adds `factory Type.fromBytes(Uint8List bytes)` factory to the class.
  bool get includeFromBinary => _includeFromBinary ?? false;
  final bool? _includeFromBinary;

  /// Adds `Uint8List toBytes()` method to the class.
  bool get includeToBinary => _includeToBinary ?? false;
  final bool? _includeToBinary;

  /// Adds `static Type fromString(String string)` factory to the class.
  ///
  /// This will implicitly enable [includeFromMap].
  bool get includeFromString => _includeFromString ?? false;
  final bool? _includeFromString;

  /// Adds `String toString({bool pretty = true})` method to the class.
  ///
  /// This will implicitly enable [includeToMap].
  bool get includeToString => _includeToString ?? false;
  final bool? _includeToString;

  /// Adds 'Type fromObject()` factory to the class.
  bool get includeFromObject => _includeFromObject ?? false;
  final bool? _includeFromObject;

  /// Adds 'Object toObject()` method to the class.
  bool get includeToObject => _includeToObject ?? false;
  final bool? _includeToObject;

  /// Adds 'String toDartString()` method to the class.
  bool get includeToDartString => _includeToDartString ?? false;
  final bool? _includeToDartString;

  String get $joType => 'ConvertUnion';

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $includeFromMap = _includeFromMap;
    final $validateFromMap = _validateFromMap;
    final $includeToMap = _includeToMap;
    final $includeFromJson = _includeFromJson;
    final $validateFromJson = _validateFromJson;
    final $includeToJson = _includeToJson;
    final $includeFromYaml = _includeFromYaml;
    final $includeFromBinary = _includeFromBinary;
    final $includeToBinary = _includeToBinary;
    final $includeFromString = _includeFromString;
    final $includeToString = _includeToString;
    final $includeFromObject = _includeFromObject;
    final $includeToObject = _includeToObject;
    final $includeToDartString = _includeToDartString;

    final $$result = super.toMap();
    if ($includeFromMap != null) $$result['includeFromMap'] = $includeFromMap;
    if ($validateFromMap != null) $$result['validateFromMap'] = $validateFromMap;
    if ($includeToMap != null) $$result['includeToMap'] = $includeToMap;
    if ($includeFromJson != null) $$result['includeFromJson'] = $includeFromJson;
    if ($validateFromJson != null) $$result['validateFromJson'] = $validateFromJson;
    if ($includeToJson != null) $$result['includeToJson'] = $includeToJson;
    if ($includeFromYaml != null) $$result['includeFromYaml'] = $includeFromYaml;
    if ($includeFromBinary != null) $$result['includeFromBinary'] = $includeFromBinary;
    if ($includeToBinary != null) $$result['includeToBinary'] = $includeToBinary;
    if ($includeFromString != null) $$result['includeFromString'] = $includeFromString;
    if ($includeToString != null) $$result['includeToString'] = $includeToString;
    if ($includeFromObject != null) $$result['includeFromObject'] = $includeFromObject;
    if ($includeToObject != null) $$result['includeToObject'] = $includeToObject;
    if ($includeToDartString != null) $$result['includeToDartString'] = $includeToDartString;
    return $$result;
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static bool? _includeFromMapFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeFromMap', aliases: const ['fromMap']);
  static bool? _validateFromMapFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'validateFromMap');
  static bool? _includeToMapFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeToMap', aliases: const ['toMap']);
  static bool? _includeFromJsonFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeFromJson', aliases: const ['fromJson']);
  static bool? _validateFromJsonFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'validateFromJson');
  static bool? _includeToJsonFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeToJson', aliases: const ['toJson']);
  static bool? _includeFromYamlFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeFromYaml', aliases: const ['fromYaml']);
  static bool? _includeFromBinaryFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeFromBinary', aliases: const ['fromBinary', 'fromBytes']);
  static bool? _includeToBinaryFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeToBinary', aliases: const ['toBinary', 'toBytes']);
  static bool? _includeFromStringFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeFromString', aliases: const ['fromString', 'fromText']);
  static bool? _includeToStringFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeToString', aliases: const ['toString', 'toText']);
  static bool? _includeFromObjectFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeFromObject', aliases: const ['fromObject']);
  static bool? _includeToObjectFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeToObject', aliases: const ['toObject']);
  static bool? _includeToDartStringFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'includeToDartString', aliases: const ['toDartString']);
}

@immutable
class CopyWith extends ParsedAnnotation {
  const CopyWith({
    BoolOrCondition? enabled,
  })  : super(
         enabled: enabled,
       );

  CopyWith.fromMap(Map<Object?, Object?> map)
    : super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'enabled',
    });
  }

  String get $joType => 'CopyWith';


  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

@immutable
class Deprecated extends ParsedAnnotation {
  const Deprecated({
    BoolOrCondition? enabled,
    required this.message,
  })  : super(
         enabled: enabled,
       );

  Deprecated.fromMap(Map<Object?, Object?> map)
    : message = _messageFromMap(map),
      super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'message',
      'enabled',
    });
  }

  final String message;

  String get $joType => 'Deprecated';

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $message = message;

    final $$result = super.toMap();
    $$result['message'] = $message;
    return $$result;
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static String _messageFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String>(fieldName: 'message');
}

/// Embeds the class or union's fields into the current class.
///
/// ```
///   class A {
///     @Embed
///     B b; 
///   }
///
///   class B {
///     Int64 i;
///     String s; 
///   }
/// ```
///
/// This will enable:
///
/// ```
///   final a = A(...);
///   a.i = 10;
///   print(a.s);
/// ```
///
/// By default, all fields are made available.
///
/// map can be used to 'rename' elements:
///
/// ```
///   class A {
///     @Embled(map: {'stringValue': 's'})
///     B b;
///   }
/// ```
@immutable
class Embed extends ParsedAnnotation {
  const Embed({
    BoolOrCondition? enabled,
    this.fields,
    this.map,
  })  : super(
         enabled: enabled,
       );

  Embed.fromMap(Map<Object?, Object?> map)
    : fields = _fieldsFromMap(map),
      map = _mapFromMap(map),
      super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'fields',
      'map',
      'enabled',
    });
  }

  final List<String>? fields;
  final Map<String, String>? map;

  String get $joType => 'Embed';

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $fields = fields;
    final $map = map;

    final $$result = super.toMap();
    if ($fields != null) $$result['fields'] = $fields;
    if ($map != null) $$result['map'] = $map;
    return $$result;
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static List<String>? _fieldsFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<List?>(fieldName: 'fields');
    if (lookup == null) return null;
    return lookup.joMapNotNull((e) => e as String).toList();
  }
  static Map<String, String>? _mapFromMap(Map<Object?, Object?> map) {
    final lookup = map.joLookupValue<Map?>(fieldName: 'map');
    if (lookup == null) return null;
    return lookup.joMapNotNull((k) => k as String, (v) => v as String);
  }
}

/// Provides a `static const values` list with all the enum values.
@immutable
class EnumValues extends ParsedAnnotation {
  const EnumValues({
    BoolOrCondition? enabled,
  })  : super(
         enabled: enabled,
       );

  EnumValues.fromMap(Map<Object?, Object?> map)
    : super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'enabled',
    });
  }

  String get $joType => 'EnumValues';


  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

@immutable
class Immutable extends ParsedAnnotation {
  const Immutable({
    BoolOrCondition? enabled,
  })  : super(
         enabled: enabled,
       );

  Immutable.fromMap(Map<Object?, Object?> map)
    : super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'enabled',
    });
  }

  String get $joType => 'Immutable';


  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

/// Specifies the strings to use for json field names and enumeration values.
@immutable
class JsonAlias extends ParsedAnnotation {
  const JsonAlias({
    BoolOrCondition? enabled,
    required this.alias,
  })  : super(
         enabled: enabled,
       );

  JsonAlias.fromMap(Map<Object?, Object?> map)
    : alias = _aliasFromMap(map),
      super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'alias',
      'enabled',
    });
  }

  final String alias;

  String get $joType => 'JsonAlias';

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $alias = alias;

    final $$result = super.toMap();
    $$result['alias'] = $alias;
    return $$result;
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static String _aliasFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String>(fieldName: 'alias');
}

@immutable
class MergeWith extends ParsedAnnotation {
  const MergeWith({
    BoolOrCondition? enabled,
  })  : super(
         enabled: enabled,
       );

  MergeWith.fromMap(Map<Object?, Object?> map)
    : super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'enabled',
    });
  }

  String get $joType => 'MergeWith';


  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

/// Used on classes and unions to indicate that a Placeholder object should be
/// generated.
@immutable
class Placeholder extends ParsedAnnotation {
  const Placeholder({
    BoolOrCondition? enabled,
    this.placeholderName = 'placeholder',
  })  : super(
         enabled: enabled,
       );

  Placeholder.fromMap(Map<Object?, Object?> map)
    : placeholderName = _placeholderNameFromMap(map),
      super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'placeholderName',
      'enabled',
    });
  }

  final String placeholderName;

  String get $joType => 'Placeholder';

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $placeholderName = placeholderName;

    final $$result = super.toMap();
    $$result['placeholderName'] = $placeholderName;
    return $$result;
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static String _placeholderNameFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String?>(fieldName: 'placeholderName') ?? 'placeholder';
}

/// Adds storage capabilities to the class.
@immutable
class Storable extends ParsedAnnotation {
  const Storable({
    BoolOrCondition? enabled,
    bool? mysql,
    bool? postgres,
    bool? redis,
  })  : _mysql = mysql,
       _postgres = postgres,
       _redis = redis,
       super(
         enabled: enabled,
       );

  Storable.fromMap(Map<Object?, Object?> map)
    : _mysql = _mysqlFromMap(map),
      _postgres = _postgresFromMap(map),
      _redis = _redisFromMap(map),
      super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'mysql',
      'postgres',
      'redis',
      'enabled',
    });
  }

  bool get mysql => _mysql ?? false;
  final bool? _mysql;
  bool get postgres => _postgres ?? false;
  final bool? _postgres;
  bool get redis => _redis ?? false;
  final bool? _redis;

  String get $joType => 'Storable';

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $mysql = _mysql;
    final $postgres = _postgres;
    final $redis = _redis;

    final $$result = super.toMap();
    if ($mysql != null) $$result['mysql'] = $mysql;
    if ($postgres != null) $$result['postgres'] = $postgres;
    if ($redis != null) $$result['redis'] = $redis;
    return $$result;
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static bool? _mysqlFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'mysql');
  static bool? _postgresFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'postgres');
  static bool? _redisFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<bool?>(fieldName: 'redis');
}

@immutable
class Table extends ParsedAnnotation {
  const Table({
    BoolOrCondition? enabled,
    this.name,
    this.postgresSchema,
  })  : super(
         enabled: enabled,
       );

  Table.fromMap(Map<Object?, Object?> map)
    : name = _nameFromMap(map),
      postgresSchema = _postgresSchemaFromMap(map),
      super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'name',
      'postgresSchema',
      'enabled',
    });
  }

  final String? name;
  final String? postgresSchema;

  String get $joType => 'Table';

  Map<String, Object?> toMap([bool $includeType=false]) {
    final $name = name;
    final $postgresSchema = postgresSchema;

    final $$result = super.toMap();
    if ($name != null) $$result['name'] = $name;
    if ($postgresSchema != null) $$result['postgresSchema'] = $postgresSchema;
    return $$result;
  }

  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);

  static String? _nameFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String?>(fieldName: 'name');
  static String? _postgresSchemaFromMap(Map<Object?, Object?> map) =>
    map.joLookupValue<String?>(fieldName: 'postgresSchema');
}

/// Provides a when() method inside Unions
@immutable
class When extends ParsedAnnotation {
  const When({
    BoolOrCondition? enabled,
  })  : super(
         enabled: enabled,
       );

  When.fromMap(Map<Object?, Object?> map)
    : super.fromMap(map)  {
    map.validateKeys(validKeys: const {
      'enabled',
    });
  }

  String get $joType => 'When';


  @override
  String toString({bool pretty = true}) =>
    toJoText(toMap(), pretty: pretty);
}

enum BoolOrCondition_ActiveElement {
  enabled,
  includedRoles,
  condition,
}

@immutable
class BoolOrCondition {
  const BoolOrCondition.enabled(bool enabled)
    : activeElement = BoolOrCondition_ActiveElement.enabled,
      _value = enabled;

  const BoolOrCondition.includedRoles(List<String> includedRoles)
    : activeElement = BoolOrCondition_ActiveElement.includedRoles,
      _value = includedRoles;

  const BoolOrCondition.condition(Condition condition)
    : activeElement = BoolOrCondition_ActiveElement.condition,
      _value = condition;
  factory BoolOrCondition.fromObject(Object object) => fromObjectOrNull(object)!;

  static BoolOrCondition? fromObjectOrNull(Object? object) {
    if (object is bool) {
      return BoolOrCondition.enabled(object);
    }
    if (object is List) {
      return BoolOrCondition.includedRoles(object.joMapNotNull((e) => e as String).toList());
    }
    if (object is Map) {
      return BoolOrCondition.condition(Condition.fromMap(object));
    }
    return null;
  }

  T when<T>({
    required T Function(bool) enabled,
    required T Function(List<String>) includedRoles,
    required T Function(Condition) condition,
  }) {
    switch (activeElement) {
      case BoolOrCondition_ActiveElement.enabled:
        return enabled(_value as bool);
      case BoolOrCondition_ActiveElement.includedRoles:
        return includedRoles(_value as List<String>);
      case BoolOrCondition_ActiveElement.condition:
        return condition(_value as Condition);
    }
  }

  final BoolOrCondition_ActiveElement activeElement;
  final Object _value;

  bool get enabled => enabledOrNull!;
  bool? get enabledOrNull =>
    activeElement == BoolOrCondition_ActiveElement.enabled
      ? _value as bool
      : null;

  List<String> get includedRoles => includedRolesOrNull!;
  List<String>? get includedRolesOrNull =>
    activeElement == BoolOrCondition_ActiveElement.includedRoles
      ? _value as List<String>
      : null;

  Condition get condition => conditionOrNull!;
  Condition? get conditionOrNull =>
    activeElement == BoolOrCondition_ActiveElement.condition
      ? _value as Condition
      : null;

  Object toObject() {
    switch (activeElement) {
      case BoolOrCondition_ActiveElement.enabled:
      case BoolOrCondition_ActiveElement.includedRoles:
        return _value;
      case BoolOrCondition_ActiveElement.condition:
        final $condition = _value as Condition;
        return $condition.toMap();
    }
  }}

void joRegister() {
  final of = JoObjectFactory();
  of.registerJoMapFactory<ParsedAnnotation>(
    'ParsedAnnotation',
    (map) => ParsedAnnotation.fromMap(map),
  );
}
